// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_default_route_reflector

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DefaultRouteReflectorResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^protocols\\.eda\\.nokia\\.com/v1$"), ""),
				},
				Default: stringdefault.StaticString("protocols.eda.nokia.com/v1"),
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^DefaultRouteReflector$"), ""),
				},
				Default: stringdefault.StaticString("DefaultRouteReflector"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the DefaultRouteReflector",
				MarkdownDescription: "name of the DefaultRouteReflector",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"as_path_options": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_own_as": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "The maximum number of times the global AS number or a local AS number of the BGP instance can appear in any received AS_PATH before it is considered a loop and considered invalid.",
								MarkdownDescription: "The maximum number of times the global AS number or a local AS number of the BGP instance can appear in any received AS_PATH before it is considered a loop and considered invalid.",
								Validators: []validator.Int64{
									int64validator.Between(0, 255),
								},
								Default: int64default.StaticInt64(0),
							},
							"remove_private_as": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"ignore_peer_as": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "If set to true then do not delete or replace a private AS number that is the same as the peer AS number.",
										MarkdownDescription: "If set to true then do not delete or replace a private AS number that is the same as the peer AS number.",
										Default:             booldefault.StaticBool(false),
									},
									"leading_only": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "If set to true then only delete or replace private AS numbers that appear before the first occurrence of a non-private ASN in the sequence of most recent ASNs in the AS path.",
										MarkdownDescription: "If set to true then only delete or replace private AS numbers that appear before the first occurrence of a non-private ASN in the sequence of most recent ASNs in the AS path.",
										Default:             booldefault.StaticBool(false),
									},
									"remove_private_asmode": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The method by which private AS numbers are removed from the advertised AS_PATH attribute.",
										MarkdownDescription: "The method by which private AS numbers are removed from the advertised AS_PATH attribute.",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"DISABLED",
												"REPLACE",
												"DELETE",
											),
										},
										Default: stringdefault.StaticString("DISABLED"),
									},
								},
								CustomType: RemovePrivateAsType{
									ObjectType: types.ObjectType{
										AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Options for removing private AS numbers (2-byte and 4-byte) from the advertised AS path towards all peers.",
								MarkdownDescription: "Options for removing private AS numbers (2-byte and 4-byte) from the advertised AS path towards all peers.",
							},
						},
						CustomType: AsPathOptionsType{
							ObjectType: types.ObjectType{
								AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "AS Path Options",
						MarkdownDescription: "AS Path Options",
					},
					"bfd": schema.BoolAttribute{
						Optional:            true,
						Description:         "Enable or disable Bi-forward Forwarding Detection (BFD) with fast failover.",
						MarkdownDescription: "Enable or disable Bi-forward Forwarding Detection (BFD) with fast failover.",
					},
					"client_ips": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of RR client IPs to which the iBGP sessions are established.",
						MarkdownDescription: "List of RR client IPs to which the iBGP sessions are established.",
					},
					"client_selector": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Label selector used to select the RouteReflectorClients to which the iBGP sessions are established.",
						MarkdownDescription: "Label selector used to select the RouteReflectorClients to which the iBGP sessions are established.",
					},
					"cluster_id": schema.StringAttribute{
						Required:            true,
						Description:         "Sets the cluster ID for route reflectors.",
						MarkdownDescription: "Sets the cluster ID for route reflectors.",
					},
					"default_bgprrgroup": schema.StringAttribute{
						Required:            true,
						Description:         "Reference to a DefaultBGPGroup.",
						MarkdownDescription: "Reference to a DefaultBGPGroup.",
					},
					"export_policy": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Reference to a Policy CR that will be used to filter routes advertised to peers.",
						MarkdownDescription: "Reference to a Policy CR that will be used to filter routes advertised to peers.",
					},
					"gr_stale_route_time": schema.Int64Attribute{
						Optional:            true,
						Description:         "Enables Graceful Restart on the peer and sets the stale route time.",
						MarkdownDescription: "Enables Graceful Restart on the peer and sets the stale route time.",
						Validators: []validator.Int64{
							int64validator.Between(1, 3600),
						},
					},
					"import_policy": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Reference to a Policy CR that will be used to filter routes received from peers.",
						MarkdownDescription: "Reference to a Policy CR that will be used to filter routes received from peers.",
					},
					"interface": schema.StringAttribute{
						Required:            true,
						Description:         "Reference to either a DefaultInterface or SystemInterface from which the session to the client will be done from.",
						MarkdownDescription: "Reference to either a DefaultInterface or SystemInterface from which the session to the client will be done from.",
					},
					"interface_kind": schema.StringAttribute{
						Required:            true,
						Description:         "Reference to a the Kind of interface from which the session to the client will be done from.",
						MarkdownDescription: "Reference to a the Kind of interface from which the session to the client will be done from.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DEFAULTINTERFACE",
								"SYSTEMINTERFACE",
							),
						},
					},
					"ipv4unicast": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"advertise_ipv6next_hops": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
								MarkdownDescription: "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables the IPv4 unicast AFISAFI.",
								MarkdownDescription: "Enables the IPv4 unicast AFISAFI.",
							},
							"prefix_limit": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"prefix_limit_accepted": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
												Validators: []validator.Int64{
													int64validator.Between(1, 4294967295),
												},
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
												Validators: []validator.Int64{
													int64validator.Between(1, 100),
												},
											},
										},
										CustomType: PrefixLimitAcceptedType{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"prefix_limit_received": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
												Validators: []validator.Int64{
													int64validator.Between(1, 4294967295),
												},
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
												Validators: []validator.Int64{
													int64validator.Between(1, 100),
												},
											},
										},
										CustomType: PrefixLimitReceivedType{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: PrefixLimitType{
									ObjectType: types.ObjectType{
										AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
							"receive_ipv6next_hops": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
								MarkdownDescription: "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
							},
						},
						CustomType: Ipv4unicastType{
							ObjectType: types.ObjectType{
								AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Parameters relating to the IPv4 unicast AFI/SAFI.",
						MarkdownDescription: "Parameters relating to the IPv4 unicast AFI/SAFI.",
					},
					"ipv6unicast": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables the IPv6 unicast AFISAFI",
								MarkdownDescription: "Enables the IPv6 unicast AFISAFI",
							},
							"prefix_limit_1": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"prefix_limit_accepted_1": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
												Validators: []validator.Int64{
													int64validator.Between(1, 4294967295),
												},
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
												Validators: []validator.Int64{
													int64validator.Between(1, 100),
												},
											},
										},
										CustomType: PrefixLimitAccepted1Type{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"prefix_limit_received_1": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
												Validators: []validator.Int64{
													int64validator.Between(1, 4294967295),
												},
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
												Validators: []validator.Int64{
													int64validator.Between(1, 100),
												},
											},
										},
										CustomType: PrefixLimitReceived1Type{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: PrefixLimit1Type{
									ObjectType: types.ObjectType{
										AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
						},
						CustomType: Ipv6unicastType{
							ObjectType: types.ObjectType{
								AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Parameters relating to the IPv6 unicast AFI/SAFI.",
						MarkdownDescription: "Parameters relating to the IPv6 unicast AFI/SAFI.",
					},
					"keychain": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a Keychain resource that will be used for authentication with the BGP peer.",
						MarkdownDescription: "Reference to a Keychain resource that will be used for authentication with the BGP peer.",
					},
					"l2vpnevpn": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"advertise_ipv6next_hops": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables advertisement of EVPN routes with IPv6 next-hops to peers.",
								MarkdownDescription: "Enables advertisement of EVPN routes with IPv6 next-hops to peers.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables the L2VPN EVPN AFISAFI.",
								MarkdownDescription: "Enables the L2VPN EVPN AFISAFI.",
							},
							"prefix_limit_2": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"prefix_limit_accepted_2": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
												Validators: []validator.Int64{
													int64validator.Between(1, 4294967295),
												},
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
												Validators: []validator.Int64{
													int64validator.Between(1, 100),
												},
											},
										},
										CustomType: PrefixLimitAccepted2Type{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"prefix_limit_received_2": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
												Validators: []validator.Int64{
													int64validator.Between(1, 4294967295),
												},
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
												Validators: []validator.Int64{
													int64validator.Between(1, 100),
												},
											},
										},
										CustomType: PrefixLimitReceived2Type{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: PrefixLimit2Type{
									ObjectType: types.ObjectType{
										AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
						},
						CustomType: L2vpnevpnType{
							ObjectType: types.ObjectType{
								AttrTypes: L2vpnevpnValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Parameters relating to the EVPN AFI/SAFI.",
						MarkdownDescription: "Parameters relating to the EVPN AFI/SAFI.",
					},
					"local_as": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"autonomous_system": schema.Int64Attribute{
								Required:            true,
								Description:         "Local Autonomous System number.",
								MarkdownDescription: "Local Autonomous System number.",
								Validators: []validator.Int64{
									int64validator.Between(1, 4294967295),
								},
							},
							"prepend_global_as": schema.BoolAttribute{
								Optional:            true,
								Description:         "When set to true, the global ASN value is prepended to the AS path in outbound routes towards each BGP peer.",
								MarkdownDescription: "When set to true, the global ASN value is prepended to the AS path in outbound routes towards each BGP peer.",
							},
							"prepend_local_as": schema.BoolAttribute{
								Optional:            true,
								Description:         "When set to true, the local AS value is prepended to the AS path of inbound routes from each EBGP peer.",
								MarkdownDescription: "When set to true, the local AS value is prepended to the AS path of inbound routes from each EBGP peer.",
							},
						},
						CustomType: LocalAsType{
							ObjectType: types.ObjectType{
								AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "The local autonomous system number advertised to peers.",
						MarkdownDescription: "The local autonomous system number advertised to peers.",
					},
					"peer_as": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"autonomous_system": schema.Int64Attribute{
								Required:            true,
								Description:         "Local Autonomous System number.",
								MarkdownDescription: "Local Autonomous System number.",
								Validators: []validator.Int64{
									int64validator.Between(1, 4294967295),
								},
							},
						},
						CustomType: PeerAsType{
							ObjectType: types.ObjectType{
								AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "The autonomous system number expected from peers.",
						MarkdownDescription: "The autonomous system number expected from peers.",
					},
					"send_community_large": schema.BoolAttribute{
						Optional:            true,
						Description:         "When false, all large (12 byte) BGP communities from all outbound routes advertised to the peer are stripped.",
						MarkdownDescription: "When false, all large (12 byte) BGP communities from all outbound routes advertised to the peer are stripped.",
					},
					"send_community_standard": schema.BoolAttribute{
						Optional:            true,
						Description:         "When false, all standard (4 byte) communities from all outbound routes advertised to the peer are stripped.",
						MarkdownDescription: "When false, all standard (4 byte) communities from all outbound routes advertised to the peer are stripped.",
					},
					"send_default_route": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"address_family": schema.ListAttribute{
								ElementType:         types.StringType,
								Required:            true,
								Description:         "Enables the sending of a synthetically generated default IPv4 or IPV6 route to each peer.",
								MarkdownDescription: "Enables the sending of a synthetically generated default IPv4 or IPV6 route to each peer.",
							},
							"export_policy": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to a Policy that should be applied to the advertised default routes, in order to set their attributes to non-default values.",
								MarkdownDescription: "Reference to a Policy that should be applied to the advertised default routes, in order to set their attributes to non-default values.",
							},
						},
						CustomType: SendDefaultRouteType{
							ObjectType: types.ObjectType{
								AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Options for controlling the generation of default routes towards BGP peers.",
						MarkdownDescription: "Options for controlling the generation of default routes towards BGP peers.",
					},
					"timers": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"connect_retry": schema.Int64Attribute{
								Optional:            true,
								Description:         "The time interval in seconds between successive attempts to establish a session with a peer.",
								MarkdownDescription: "The time interval in seconds between successive attempts to establish a session with a peer.",
								Validators: []validator.Int64{
									int64validator.Between(1, 65535),
								},
							},
							"hold_time": schema.Int64Attribute{
								Optional:            true,
								Description:         "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
								MarkdownDescription: "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
								Validators: []validator.Int64{
									int64validator.Between(0, 65535),
								},
							},
							"keep_alive": schema.Int64Attribute{
								Optional:            true,
								Description:         "The interval in seconds between successive keepalive messages sent to the peer.",
								MarkdownDescription: "The interval in seconds between successive keepalive messages sent to the peer.",
								Validators: []validator.Int64{
									int64validator.Between(0, 21845),
								},
							},
							"minimum_advertisement_interval": schema.Int64Attribute{
								Optional:            true,
								Description:         "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
								MarkdownDescription: "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
								Validators: []validator.Int64{
									int64validator.Between(1, 255),
								},
							},
						},
						CustomType: TimersType{
							ObjectType: types.ObjectType{
								AttrTypes: TimersValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Timer configurations",
						MarkdownDescription: "Timer configurations",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "DefaultRouteReflector enables the configuration of iBGP sessions to RouteReflectorClients. It includes settings for the DefaultInterface, BGP group, client selectors, and the Cluster ID. Additionally, it allows for the configuration of L2VPN EVPN settings and applies common BGP configuration settings to manage routing efficiently within the network.",
				MarkdownDescription: "DefaultRouteReflector enables the configuration of iBGP sessions to RouteReflectorClients. It includes settings for the DefaultInterface, BGP group, client selectors, and the Cluster ID. Additionally, it allows for the configuration of L2VPN EVPN settings and applies common BGP configuration settings to manage routing efficiently within the network.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"health": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates the health score of the Route Reflector.",
						MarkdownDescription: "Indicates the health score of the Route Reflector.",
					},
					"health_score_reason": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates the reason for the health score.",
						MarkdownDescription: "Indicates the reason for the health score.",
					},
					"last_change": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The time when the state of the resource last changed.",
						MarkdownDescription: "The time when the state of the resource last changed.",
					},
					"num_route_reflector_bgppeers": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Total number of configured route reflector client peers on the route reflector.",
						MarkdownDescription: "Total number of configured route reflector client peers on the route reflector.",
					},
					"num_route_reflector_bgppeers_oper_down": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Total number of configured route reflector client peers on the route reflector that are operationally down.",
						MarkdownDescription: "Total number of configured route reflector client peers on the route reflector that are operationally down.",
					},
					"oper_down_route_reflector_peers": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "List of route reflector BGPPeers which are operationally down.",
						MarkdownDescription: "List of route reflector BGPPeers which are operationally down.",
					},
					"operational_state": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Operational state of the Route Reflector.",
						MarkdownDescription: "Operational state of the Route Reflector.",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "DefaultRouteReflectorStatus defines the observed state of DefaultRouteReflector",
				MarkdownDescription: "DefaultRouteReflectorStatus defines the observed state of DefaultRouteReflector",
			},
		},
	}
}

type DefaultRouteReflectorModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathOptionsAttribute, ok := attributes["as_path_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_options is missing from object`)

		return nil, diags
	}

	asPathOptionsVal, ok := asPathOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_options expected to be basetypes.ObjectValue, was: %T`, asPathOptionsAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return nil, diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.BoolValue, was: %T`, bfdAttribute))
	}

	clientIpsAttribute, ok := attributes["client_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_ips is missing from object`)

		return nil, diags
	}

	clientIpsVal, ok := clientIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_ips expected to be basetypes.ListValue, was: %T`, clientIpsAttribute))
	}

	clientSelectorAttribute, ok := attributes["client_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_selector is missing from object`)

		return nil, diags
	}

	clientSelectorVal, ok := clientSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_selector expected to be basetypes.ListValue, was: %T`, clientSelectorAttribute))
	}

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return nil, diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	defaultBgprrgroupAttribute, ok := attributes["default_bgprrgroup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_bgprrgroup is missing from object`)

		return nil, diags
	}

	defaultBgprrgroupVal, ok := defaultBgprrgroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_bgprrgroup expected to be basetypes.StringValue, was: %T`, defaultBgprrgroupAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	grStaleRouteTimeAttribute, ok := attributes["gr_stale_route_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gr_stale_route_time is missing from object`)

		return nil, diags
	}

	grStaleRouteTimeVal, ok := grStaleRouteTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gr_stale_route_time expected to be basetypes.Int64Value, was: %T`, grStaleRouteTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceKindAttribute, ok := attributes["interface_kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_kind is missing from object`)

		return nil, diags
	}

	interfaceKindVal, ok := interfaceKindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_kind expected to be basetypes.StringValue, was: %T`, interfaceKindAttribute))
	}

	ipv4unicastAttribute, ok := attributes["ipv4unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4unicast is missing from object`)

		return nil, diags
	}

	ipv4unicastVal, ok := ipv4unicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4unicast expected to be basetypes.ObjectValue, was: %T`, ipv4unicastAttribute))
	}

	ipv6unicastAttribute, ok := attributes["ipv6unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6unicast is missing from object`)

		return nil, diags
	}

	ipv6unicastVal, ok := ipv6unicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6unicast expected to be basetypes.ObjectValue, was: %T`, ipv6unicastAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return nil, diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	l2vpnevpnAttribute, ok := attributes["l2vpnevpn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2vpnevpn is missing from object`)

		return nil, diags
	}

	l2vpnevpnVal, ok := l2vpnevpnAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2vpnevpn expected to be basetypes.ObjectValue, was: %T`, l2vpnevpnAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return nil, diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.ObjectValue, was: %T`, localAsAttribute))
	}

	peerAsAttribute, ok := attributes["peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_as is missing from object`)

		return nil, diags
	}

	peerAsVal, ok := peerAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_as expected to be basetypes.ObjectValue, was: %T`, peerAsAttribute))
	}

	sendCommunityLargeAttribute, ok := attributes["send_community_large"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_large is missing from object`)

		return nil, diags
	}

	sendCommunityLargeVal, ok := sendCommunityLargeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_large expected to be basetypes.BoolValue, was: %T`, sendCommunityLargeAttribute))
	}

	sendCommunityStandardAttribute, ok := attributes["send_community_standard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_standard is missing from object`)

		return nil, diags
	}

	sendCommunityStandardVal, ok := sendCommunityStandardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_standard expected to be basetypes.BoolValue, was: %T`, sendCommunityStandardAttribute))
	}

	sendDefaultRouteAttribute, ok := attributes["send_default_route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_default_route is missing from object`)

		return nil, diags
	}

	sendDefaultRouteVal, ok := sendDefaultRouteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_default_route expected to be basetypes.ObjectValue, was: %T`, sendDefaultRouteAttribute))
	}

	timersAttribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers is missing from object`)

		return nil, diags
	}

	timersVal, ok := timersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers expected to be basetypes.ObjectValue, was: %T`, timersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		AsPathOptions:         asPathOptionsVal,
		Bfd:                   bfdVal,
		ClientIps:             clientIpsVal,
		ClientSelector:        clientSelectorVal,
		ClusterId:             clusterIdVal,
		DefaultBgprrgroup:     defaultBgprrgroupVal,
		ExportPolicy:          exportPolicyVal,
		GrStaleRouteTime:      grStaleRouteTimeVal,
		ImportPolicy:          importPolicyVal,
		Interface:             interfaceVal,
		InterfaceKind:         interfaceKindVal,
		Ipv4unicast:           ipv4unicastVal,
		Ipv6unicast:           ipv6unicastVal,
		Keychain:              keychainVal,
		L2vpnevpn:             l2vpnevpnVal,
		LocalAs:               localAsVal,
		PeerAs:                peerAsVal,
		SendCommunityLarge:    sendCommunityLargeVal,
		SendCommunityStandard: sendCommunityStandardVal,
		SendDefaultRoute:      sendDefaultRouteVal,
		Timers:                timersVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	asPathOptionsAttribute, ok := attributes["as_path_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_options is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	asPathOptionsVal, ok := asPathOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_options expected to be basetypes.ObjectValue, was: %T`, asPathOptionsAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.BoolValue, was: %T`, bfdAttribute))
	}

	clientIpsAttribute, ok := attributes["client_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_ips is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	clientIpsVal, ok := clientIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_ips expected to be basetypes.ListValue, was: %T`, clientIpsAttribute))
	}

	clientSelectorAttribute, ok := attributes["client_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_selector is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	clientSelectorVal, ok := clientSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_selector expected to be basetypes.ListValue, was: %T`, clientSelectorAttribute))
	}

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	defaultBgprrgroupAttribute, ok := attributes["default_bgprrgroup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_bgprrgroup is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	defaultBgprrgroupVal, ok := defaultBgprrgroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_bgprrgroup expected to be basetypes.StringValue, was: %T`, defaultBgprrgroupAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	grStaleRouteTimeAttribute, ok := attributes["gr_stale_route_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gr_stale_route_time is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	grStaleRouteTimeVal, ok := grStaleRouteTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gr_stale_route_time expected to be basetypes.Int64Value, was: %T`, grStaleRouteTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceKindAttribute, ok := attributes["interface_kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_kind is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	interfaceKindVal, ok := interfaceKindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_kind expected to be basetypes.StringValue, was: %T`, interfaceKindAttribute))
	}

	ipv4unicastAttribute, ok := attributes["ipv4unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4unicast is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipv4unicastVal, ok := ipv4unicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4unicast expected to be basetypes.ObjectValue, was: %T`, ipv4unicastAttribute))
	}

	ipv6unicastAttribute, ok := attributes["ipv6unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6unicast is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipv6unicastVal, ok := ipv6unicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6unicast expected to be basetypes.ObjectValue, was: %T`, ipv6unicastAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	l2vpnevpnAttribute, ok := attributes["l2vpnevpn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2vpnevpn is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	l2vpnevpnVal, ok := l2vpnevpnAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2vpnevpn expected to be basetypes.ObjectValue, was: %T`, l2vpnevpnAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.ObjectValue, was: %T`, localAsAttribute))
	}

	peerAsAttribute, ok := attributes["peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_as is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	peerAsVal, ok := peerAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_as expected to be basetypes.ObjectValue, was: %T`, peerAsAttribute))
	}

	sendCommunityLargeAttribute, ok := attributes["send_community_large"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_large is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	sendCommunityLargeVal, ok := sendCommunityLargeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_large expected to be basetypes.BoolValue, was: %T`, sendCommunityLargeAttribute))
	}

	sendCommunityStandardAttribute, ok := attributes["send_community_standard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_standard is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	sendCommunityStandardVal, ok := sendCommunityStandardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_standard expected to be basetypes.BoolValue, was: %T`, sendCommunityStandardAttribute))
	}

	sendDefaultRouteAttribute, ok := attributes["send_default_route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_default_route is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	sendDefaultRouteVal, ok := sendDefaultRouteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_default_route expected to be basetypes.ObjectValue, was: %T`, sendDefaultRouteAttribute))
	}

	timersAttribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	timersVal, ok := timersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers expected to be basetypes.ObjectValue, was: %T`, timersAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		AsPathOptions:         asPathOptionsVal,
		Bfd:                   bfdVal,
		ClientIps:             clientIpsVal,
		ClientSelector:        clientSelectorVal,
		ClusterId:             clusterIdVal,
		DefaultBgprrgroup:     defaultBgprrgroupVal,
		ExportPolicy:          exportPolicyVal,
		GrStaleRouteTime:      grStaleRouteTimeVal,
		ImportPolicy:          importPolicyVal,
		Interface:             interfaceVal,
		InterfaceKind:         interfaceKindVal,
		Ipv4unicast:           ipv4unicastVal,
		Ipv6unicast:           ipv6unicastVal,
		Keychain:              keychainVal,
		L2vpnevpn:             l2vpnevpnVal,
		LocalAs:               localAsVal,
		PeerAs:                peerAsVal,
		SendCommunityLarge:    sendCommunityLargeVal,
		SendCommunityStandard: sendCommunityStandardVal,
		SendDefaultRoute:      sendDefaultRouteVal,
		Timers:                timersVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	AsPathOptions         basetypes.ObjectValue `tfsdk:"as_path_options"`
	Bfd                   basetypes.BoolValue   `tfsdk:"bfd"`
	ClientIps             basetypes.ListValue   `tfsdk:"client_ips"`
	ClientSelector        basetypes.ListValue   `tfsdk:"client_selector"`
	ClusterId             basetypes.StringValue `tfsdk:"cluster_id"`
	DefaultBgprrgroup     basetypes.StringValue `tfsdk:"default_bgprrgroup"`
	ExportPolicy          basetypes.ListValue   `tfsdk:"export_policy"`
	GrStaleRouteTime      basetypes.Int64Value  `tfsdk:"gr_stale_route_time"`
	ImportPolicy          basetypes.ListValue   `tfsdk:"import_policy"`
	Interface             basetypes.StringValue `tfsdk:"interface"`
	InterfaceKind         basetypes.StringValue `tfsdk:"interface_kind"`
	Ipv4unicast           basetypes.ObjectValue `tfsdk:"ipv4unicast"`
	Ipv6unicast           basetypes.ObjectValue `tfsdk:"ipv6unicast"`
	Keychain              basetypes.StringValue `tfsdk:"keychain"`
	L2vpnevpn             basetypes.ObjectValue `tfsdk:"l2vpnevpn"`
	LocalAs               basetypes.ObjectValue `tfsdk:"local_as"`
	PeerAs                basetypes.ObjectValue `tfsdk:"peer_as"`
	SendCommunityLarge    basetypes.BoolValue   `tfsdk:"send_community_large"`
	SendCommunityStandard basetypes.BoolValue   `tfsdk:"send_community_standard"`
	SendDefaultRoute      basetypes.ObjectValue `tfsdk:"send_default_route"`
	Timers                basetypes.ObjectValue `tfsdk:"timers"`
	state                 attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 21)

	var val tftypes.Value
	var err error

	attrTypes["as_path_options"] = basetypes.ObjectType{
		AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["bfd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["client_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["client_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["cluster_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["default_bgprrgroup"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gr_stale_route_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv4unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["keychain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l2vpnevpn"] = basetypes.ObjectType{
		AttrTypes: L2vpnevpnValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_as"] = basetypes.ObjectType{
		AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["peer_as"] = basetypes.ObjectType{
		AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["send_community_large"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["send_community_standard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["send_default_route"] = basetypes.ObjectType{
		AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["timers"] = basetypes.ObjectType{
		AttrTypes: TimersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 21)

		val, err = v.AsPathOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_options"] = val

		val, err = v.Bfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.ClientIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_ips"] = val

		val, err = v.ClientSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_selector"] = val

		val, err = v.ClusterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_id"] = val

		val, err = v.DefaultBgprrgroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_bgprrgroup"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.GrStaleRouteTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gr_stale_route_time"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.InterfaceKind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_kind"] = val

		val, err = v.Ipv4unicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4unicast"] = val

		val, err = v.Ipv6unicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6unicast"] = val

		val, err = v.Keychain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keychain"] = val

		val, err = v.L2vpnevpn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l2vpnevpn"] = val

		val, err = v.LocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_as"] = val

		val, err = v.PeerAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_as"] = val

		val, err = v.SendCommunityLarge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_community_large"] = val

		val, err = v.SendCommunityStandard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_community_standard"] = val

		val, err = v.SendDefaultRoute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_default_route"] = val

		val, err = v.Timers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var asPathOptions basetypes.ObjectValue

	if v.AsPathOptions.IsNull() {
		asPathOptions = types.ObjectNull(
			AsPathOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.AsPathOptions.IsUnknown() {
		asPathOptions = types.ObjectUnknown(
			AsPathOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AsPathOptions.IsNull() && !v.AsPathOptions.IsUnknown() {
		asPathOptions = types.ObjectValueMust(
			AsPathOptionsValue{}.AttributeTypes(ctx),
			v.AsPathOptions.Attributes(),
		)
	}

	var ipv4unicast basetypes.ObjectValue

	if v.Ipv4unicast.IsNull() {
		ipv4unicast = types.ObjectNull(
			Ipv4unicastValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4unicast.IsUnknown() {
		ipv4unicast = types.ObjectUnknown(
			Ipv4unicastValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4unicast.IsNull() && !v.Ipv4unicast.IsUnknown() {
		ipv4unicast = types.ObjectValueMust(
			Ipv4unicastValue{}.AttributeTypes(ctx),
			v.Ipv4unicast.Attributes(),
		)
	}

	var ipv6unicast basetypes.ObjectValue

	if v.Ipv6unicast.IsNull() {
		ipv6unicast = types.ObjectNull(
			Ipv6unicastValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6unicast.IsUnknown() {
		ipv6unicast = types.ObjectUnknown(
			Ipv6unicastValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6unicast.IsNull() && !v.Ipv6unicast.IsUnknown() {
		ipv6unicast = types.ObjectValueMust(
			Ipv6unicastValue{}.AttributeTypes(ctx),
			v.Ipv6unicast.Attributes(),
		)
	}

	var l2vpnevpn basetypes.ObjectValue

	if v.L2vpnevpn.IsNull() {
		l2vpnevpn = types.ObjectNull(
			L2vpnevpnValue{}.AttributeTypes(ctx),
		)
	}

	if v.L2vpnevpn.IsUnknown() {
		l2vpnevpn = types.ObjectUnknown(
			L2vpnevpnValue{}.AttributeTypes(ctx),
		)
	}

	if !v.L2vpnevpn.IsNull() && !v.L2vpnevpn.IsUnknown() {
		l2vpnevpn = types.ObjectValueMust(
			L2vpnevpnValue{}.AttributeTypes(ctx),
			v.L2vpnevpn.Attributes(),
		)
	}

	var localAs basetypes.ObjectValue

	if v.LocalAs.IsNull() {
		localAs = types.ObjectNull(
			LocalAsValue{}.AttributeTypes(ctx),
		)
	}

	if v.LocalAs.IsUnknown() {
		localAs = types.ObjectUnknown(
			LocalAsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LocalAs.IsNull() && !v.LocalAs.IsUnknown() {
		localAs = types.ObjectValueMust(
			LocalAsValue{}.AttributeTypes(ctx),
			v.LocalAs.Attributes(),
		)
	}

	var peerAs basetypes.ObjectValue

	if v.PeerAs.IsNull() {
		peerAs = types.ObjectNull(
			PeerAsValue{}.AttributeTypes(ctx),
		)
	}

	if v.PeerAs.IsUnknown() {
		peerAs = types.ObjectUnknown(
			PeerAsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PeerAs.IsNull() && !v.PeerAs.IsUnknown() {
		peerAs = types.ObjectValueMust(
			PeerAsValue{}.AttributeTypes(ctx),
			v.PeerAs.Attributes(),
		)
	}

	var sendDefaultRoute basetypes.ObjectValue

	if v.SendDefaultRoute.IsNull() {
		sendDefaultRoute = types.ObjectNull(
			SendDefaultRouteValue{}.AttributeTypes(ctx),
		)
	}

	if v.SendDefaultRoute.IsUnknown() {
		sendDefaultRoute = types.ObjectUnknown(
			SendDefaultRouteValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SendDefaultRoute.IsNull() && !v.SendDefaultRoute.IsUnknown() {
		sendDefaultRoute = types.ObjectValueMust(
			SendDefaultRouteValue{}.AttributeTypes(ctx),
			v.SendDefaultRoute.Attributes(),
		)
	}

	var timers basetypes.ObjectValue

	if v.Timers.IsNull() {
		timers = types.ObjectNull(
			TimersValue{}.AttributeTypes(ctx),
		)
	}

	if v.Timers.IsUnknown() {
		timers = types.ObjectUnknown(
			TimersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Timers.IsNull() && !v.Timers.IsUnknown() {
		timers = types.ObjectValueMust(
			TimersValue{}.AttributeTypes(ctx),
			v.Timers.Attributes(),
		)
	}

	var clientIpsVal basetypes.ListValue
	switch {
	case v.ClientIps.IsUnknown():
		clientIpsVal = types.ListUnknown(types.StringType)
	case v.ClientIps.IsNull():
		clientIpsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		clientIpsVal, d = types.ListValue(types.StringType, v.ClientIps.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
			},
			"bfd": basetypes.BoolType{},
			"client_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"client_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_id":         basetypes.StringType{},
			"default_bgprrgroup": basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interface":      basetypes.StringType{},
			"interface_kind": basetypes.StringType{},
			"ipv4unicast": basetypes.ObjectType{
				AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
			},
			"ipv6unicast": basetypes.ObjectType{
				AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"l2vpnevpn": basetypes.ObjectType{
				AttrTypes: L2vpnevpnValue{}.AttributeTypes(ctx),
			},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
			},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
			},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var clientSelectorVal basetypes.ListValue
	switch {
	case v.ClientSelector.IsUnknown():
		clientSelectorVal = types.ListUnknown(types.StringType)
	case v.ClientSelector.IsNull():
		clientSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		clientSelectorVal, d = types.ListValue(types.StringType, v.ClientSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
			},
			"bfd": basetypes.BoolType{},
			"client_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"client_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_id":         basetypes.StringType{},
			"default_bgprrgroup": basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interface":      basetypes.StringType{},
			"interface_kind": basetypes.StringType{},
			"ipv4unicast": basetypes.ObjectType{
				AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
			},
			"ipv6unicast": basetypes.ObjectType{
				AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"l2vpnevpn": basetypes.ObjectType{
				AttrTypes: L2vpnevpnValue{}.AttributeTypes(ctx),
			},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
			},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
			},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var exportPolicyVal basetypes.ListValue
	switch {
	case v.ExportPolicy.IsUnknown():
		exportPolicyVal = types.ListUnknown(types.StringType)
	case v.ExportPolicy.IsNull():
		exportPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exportPolicyVal, d = types.ListValue(types.StringType, v.ExportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
			},
			"bfd": basetypes.BoolType{},
			"client_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"client_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_id":         basetypes.StringType{},
			"default_bgprrgroup": basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interface":      basetypes.StringType{},
			"interface_kind": basetypes.StringType{},
			"ipv4unicast": basetypes.ObjectType{
				AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
			},
			"ipv6unicast": basetypes.ObjectType{
				AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"l2vpnevpn": basetypes.ObjectType{
				AttrTypes: L2vpnevpnValue{}.AttributeTypes(ctx),
			},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
			},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
			},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var importPolicyVal basetypes.ListValue
	switch {
	case v.ImportPolicy.IsUnknown():
		importPolicyVal = types.ListUnknown(types.StringType)
	case v.ImportPolicy.IsNull():
		importPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		importPolicyVal, d = types.ListValue(types.StringType, v.ImportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
			},
			"bfd": basetypes.BoolType{},
			"client_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"client_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_id":         basetypes.StringType{},
			"default_bgprrgroup": basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interface":      basetypes.StringType{},
			"interface_kind": basetypes.StringType{},
			"ipv4unicast": basetypes.ObjectType{
				AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
			},
			"ipv6unicast": basetypes.ObjectType{
				AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"l2vpnevpn": basetypes.ObjectType{
				AttrTypes: L2vpnevpnValue{}.AttributeTypes(ctx),
			},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
			},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
			},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path_options": basetypes.ObjectType{
			AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
		},
		"bfd": basetypes.BoolType{},
		"client_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"client_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"cluster_id":         basetypes.StringType{},
		"default_bgprrgroup": basetypes.StringType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gr_stale_route_time": basetypes.Int64Type{},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"interface":      basetypes.StringType{},
		"interface_kind": basetypes.StringType{},
		"ipv4unicast": basetypes.ObjectType{
			AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
		},
		"ipv6unicast": basetypes.ObjectType{
			AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
		},
		"keychain": basetypes.StringType{},
		"l2vpnevpn": basetypes.ObjectType{
			AttrTypes: L2vpnevpnValue{}.AttributeTypes(ctx),
		},
		"local_as": basetypes.ObjectType{
			AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
		},
		"peer_as": basetypes.ObjectType{
			AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
		},
		"send_community_large":    basetypes.BoolType{},
		"send_community_standard": basetypes.BoolType{},
		"send_default_route": basetypes.ObjectType{
			AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
		},
		"timers": basetypes.ObjectType{
			AttrTypes: TimersValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_options":         asPathOptions,
			"bfd":                     v.Bfd,
			"client_ips":              clientIpsVal,
			"client_selector":         clientSelectorVal,
			"cluster_id":              v.ClusterId,
			"default_bgprrgroup":      v.DefaultBgprrgroup,
			"export_policy":           exportPolicyVal,
			"gr_stale_route_time":     v.GrStaleRouteTime,
			"import_policy":           importPolicyVal,
			"interface":               v.Interface,
			"interface_kind":          v.InterfaceKind,
			"ipv4unicast":             ipv4unicast,
			"ipv6unicast":             ipv6unicast,
			"keychain":                v.Keychain,
			"l2vpnevpn":               l2vpnevpn,
			"local_as":                localAs,
			"peer_as":                 peerAs,
			"send_community_large":    v.SendCommunityLarge,
			"send_community_standard": v.SendCommunityStandard,
			"send_default_route":      sendDefaultRoute,
			"timers":                  timers,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathOptions.Equal(other.AsPathOptions) {
		return false
	}

	if !v.Bfd.Equal(other.Bfd) {
		return false
	}

	if !v.ClientIps.Equal(other.ClientIps) {
		return false
	}

	if !v.ClientSelector.Equal(other.ClientSelector) {
		return false
	}

	if !v.ClusterId.Equal(other.ClusterId) {
		return false
	}

	if !v.DefaultBgprrgroup.Equal(other.DefaultBgprrgroup) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.GrStaleRouteTime.Equal(other.GrStaleRouteTime) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.InterfaceKind.Equal(other.InterfaceKind) {
		return false
	}

	if !v.Ipv4unicast.Equal(other.Ipv4unicast) {
		return false
	}

	if !v.Ipv6unicast.Equal(other.Ipv6unicast) {
		return false
	}

	if !v.Keychain.Equal(other.Keychain) {
		return false
	}

	if !v.L2vpnevpn.Equal(other.L2vpnevpn) {
		return false
	}

	if !v.LocalAs.Equal(other.LocalAs) {
		return false
	}

	if !v.PeerAs.Equal(other.PeerAs) {
		return false
	}

	if !v.SendCommunityLarge.Equal(other.SendCommunityLarge) {
		return false
	}

	if !v.SendCommunityStandard.Equal(other.SendCommunityStandard) {
		return false
	}

	if !v.SendDefaultRoute.Equal(other.SendDefaultRoute) {
		return false
	}

	if !v.Timers.Equal(other.Timers) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_options": basetypes.ObjectType{
			AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
		},
		"bfd": basetypes.BoolType{},
		"client_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"client_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"cluster_id":         basetypes.StringType{},
		"default_bgprrgroup": basetypes.StringType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gr_stale_route_time": basetypes.Int64Type{},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"interface":      basetypes.StringType{},
		"interface_kind": basetypes.StringType{},
		"ipv4unicast": basetypes.ObjectType{
			AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
		},
		"ipv6unicast": basetypes.ObjectType{
			AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
		},
		"keychain": basetypes.StringType{},
		"l2vpnevpn": basetypes.ObjectType{
			AttrTypes: L2vpnevpnValue{}.AttributeTypes(ctx),
		},
		"local_as": basetypes.ObjectType{
			AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
		},
		"peer_as": basetypes.ObjectType{
			AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
		},
		"send_community_large":    basetypes.BoolType{},
		"send_community_standard": basetypes.BoolType{},
		"send_default_route": basetypes.ObjectType{
			AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
		},
		"timers": basetypes.ObjectType{
			AttrTypes: TimersValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AsPathOptionsType{}

type AsPathOptionsType struct {
	basetypes.ObjectType
}

func (t AsPathOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(AsPathOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AsPathOptionsType) String() string {
	return "AsPathOptionsType"
}

func (t AsPathOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowOwnAsAttribute, ok := attributes["allow_own_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_own_as is missing from object`)

		return nil, diags
	}

	allowOwnAsVal, ok := allowOwnAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_own_as expected to be basetypes.Int64Value, was: %T`, allowOwnAsAttribute))
	}

	removePrivateAsAttribute, ok := attributes["remove_private_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as is missing from object`)

		return nil, diags
	}

	removePrivateAsVal, ok := removePrivateAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as expected to be basetypes.ObjectValue, was: %T`, removePrivateAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AsPathOptionsValue{
		AllowOwnAs:      allowOwnAsVal,
		RemovePrivateAs: removePrivateAsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAsPathOptionsValueNull() AsPathOptionsValue {
	return AsPathOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewAsPathOptionsValueUnknown() AsPathOptionsValue {
	return AsPathOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAsPathOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AsPathOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AsPathOptionsValue Attribute Value",
				"While creating a AsPathOptionsValue value, a missing attribute value was detected. "+
					"A AsPathOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AsPathOptionsValue Attribute Type",
				"While creating a AsPathOptionsValue value, an invalid attribute value was detected. "+
					"A AsPathOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AsPathOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AsPathOptionsValue Attribute Value",
				"While creating a AsPathOptionsValue value, an extra attribute value was detected. "+
					"A AsPathOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AsPathOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAsPathOptionsValueUnknown(), diags
	}

	allowOwnAsAttribute, ok := attributes["allow_own_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_own_as is missing from object`)

		return NewAsPathOptionsValueUnknown(), diags
	}

	allowOwnAsVal, ok := allowOwnAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_own_as expected to be basetypes.Int64Value, was: %T`, allowOwnAsAttribute))
	}

	removePrivateAsAttribute, ok := attributes["remove_private_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as is missing from object`)

		return NewAsPathOptionsValueUnknown(), diags
	}

	removePrivateAsVal, ok := removePrivateAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as expected to be basetypes.ObjectValue, was: %T`, removePrivateAsAttribute))
	}

	if diags.HasError() {
		return NewAsPathOptionsValueUnknown(), diags
	}

	return AsPathOptionsValue{
		AllowOwnAs:      allowOwnAsVal,
		RemovePrivateAs: removePrivateAsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAsPathOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AsPathOptionsValue {
	object, diags := NewAsPathOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAsPathOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AsPathOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAsPathOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAsPathOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAsPathOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAsPathOptionsValueMust(AsPathOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AsPathOptionsType) ValueType(ctx context.Context) attr.Value {
	return AsPathOptionsValue{}
}

var _ basetypes.ObjectValuable = AsPathOptionsValue{}

type AsPathOptionsValue struct {
	AllowOwnAs      basetypes.Int64Value  `tfsdk:"allow_own_as"`
	RemovePrivateAs basetypes.ObjectValue `tfsdk:"remove_private_as"`
	state           attr.ValueState
}

func (v AsPathOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["allow_own_as"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remove_private_as"] = basetypes.ObjectType{
		AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AllowOwnAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_own_as"] = val

		val, err = v.RemovePrivateAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove_private_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AsPathOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AsPathOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AsPathOptionsValue) String() string {
	return "AsPathOptionsValue"
}

func (v AsPathOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var removePrivateAs basetypes.ObjectValue

	if v.RemovePrivateAs.IsNull() {
		removePrivateAs = types.ObjectNull(
			RemovePrivateAsValue{}.AttributeTypes(ctx),
		)
	}

	if v.RemovePrivateAs.IsUnknown() {
		removePrivateAs = types.ObjectUnknown(
			RemovePrivateAsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RemovePrivateAs.IsNull() && !v.RemovePrivateAs.IsUnknown() {
		removePrivateAs = types.ObjectValueMust(
			RemovePrivateAsValue{}.AttributeTypes(ctx),
			v.RemovePrivateAs.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"allow_own_as": basetypes.Int64Type{},
		"remove_private_as": basetypes.ObjectType{
			AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_own_as":      v.AllowOwnAs,
			"remove_private_as": removePrivateAs,
		})

	return objVal, diags
}

func (v AsPathOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(AsPathOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowOwnAs.Equal(other.AllowOwnAs) {
		return false
	}

	if !v.RemovePrivateAs.Equal(other.RemovePrivateAs) {
		return false
	}

	return true
}

func (v AsPathOptionsValue) Type(ctx context.Context) attr.Type {
	return AsPathOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AsPathOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_own_as": basetypes.Int64Type{},
		"remove_private_as": basetypes.ObjectType{
			AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = RemovePrivateAsType{}

type RemovePrivateAsType struct {
	basetypes.ObjectType
}

func (t RemovePrivateAsType) Equal(o attr.Type) bool {
	other, ok := o.(RemovePrivateAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemovePrivateAsType) String() string {
	return "RemovePrivateAsType"
}

func (t RemovePrivateAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ignorePeerAsAttribute, ok := attributes["ignore_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_peer_as is missing from object`)

		return nil, diags
	}

	ignorePeerAsVal, ok := ignorePeerAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_peer_as expected to be basetypes.BoolValue, was: %T`, ignorePeerAsAttribute))
	}

	leadingOnlyAttribute, ok := attributes["leading_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leading_only is missing from object`)

		return nil, diags
	}

	leadingOnlyVal, ok := leadingOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leading_only expected to be basetypes.BoolValue, was: %T`, leadingOnlyAttribute))
	}

	removePrivateAsmodeAttribute, ok := attributes["remove_private_asmode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_asmode is missing from object`)

		return nil, diags
	}

	removePrivateAsmodeVal, ok := removePrivateAsmodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_asmode expected to be basetypes.StringValue, was: %T`, removePrivateAsmodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemovePrivateAsValue{
		IgnorePeerAs:        ignorePeerAsVal,
		LeadingOnly:         leadingOnlyVal,
		RemovePrivateAsmode: removePrivateAsmodeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRemovePrivateAsValueNull() RemovePrivateAsValue {
	return RemovePrivateAsValue{
		state: attr.ValueStateNull,
	}
}

func NewRemovePrivateAsValueUnknown() RemovePrivateAsValue {
	return RemovePrivateAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemovePrivateAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemovePrivateAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemovePrivateAsValue Attribute Value",
				"While creating a RemovePrivateAsValue value, a missing attribute value was detected. "+
					"A RemovePrivateAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemovePrivateAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemovePrivateAsValue Attribute Type",
				"While creating a RemovePrivateAsValue value, an invalid attribute value was detected. "+
					"A RemovePrivateAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemovePrivateAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemovePrivateAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemovePrivateAsValue Attribute Value",
				"While creating a RemovePrivateAsValue value, an extra attribute value was detected. "+
					"A RemovePrivateAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemovePrivateAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemovePrivateAsValueUnknown(), diags
	}

	ignorePeerAsAttribute, ok := attributes["ignore_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_peer_as is missing from object`)

		return NewRemovePrivateAsValueUnknown(), diags
	}

	ignorePeerAsVal, ok := ignorePeerAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_peer_as expected to be basetypes.BoolValue, was: %T`, ignorePeerAsAttribute))
	}

	leadingOnlyAttribute, ok := attributes["leading_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leading_only is missing from object`)

		return NewRemovePrivateAsValueUnknown(), diags
	}

	leadingOnlyVal, ok := leadingOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leading_only expected to be basetypes.BoolValue, was: %T`, leadingOnlyAttribute))
	}

	removePrivateAsmodeAttribute, ok := attributes["remove_private_asmode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_asmode is missing from object`)

		return NewRemovePrivateAsValueUnknown(), diags
	}

	removePrivateAsmodeVal, ok := removePrivateAsmodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_asmode expected to be basetypes.StringValue, was: %T`, removePrivateAsmodeAttribute))
	}

	if diags.HasError() {
		return NewRemovePrivateAsValueUnknown(), diags
	}

	return RemovePrivateAsValue{
		IgnorePeerAs:        ignorePeerAsVal,
		LeadingOnly:         leadingOnlyVal,
		RemovePrivateAsmode: removePrivateAsmodeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRemovePrivateAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemovePrivateAsValue {
	object, diags := NewRemovePrivateAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemovePrivateAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemovePrivateAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemovePrivateAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemovePrivateAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemovePrivateAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemovePrivateAsValueMust(RemovePrivateAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemovePrivateAsType) ValueType(ctx context.Context) attr.Value {
	return RemovePrivateAsValue{}
}

var _ basetypes.ObjectValuable = RemovePrivateAsValue{}

type RemovePrivateAsValue struct {
	IgnorePeerAs        basetypes.BoolValue   `tfsdk:"ignore_peer_as"`
	LeadingOnly         basetypes.BoolValue   `tfsdk:"leading_only"`
	RemovePrivateAsmode basetypes.StringValue `tfsdk:"remove_private_asmode"`
	state               attr.ValueState
}

func (v RemovePrivateAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["ignore_peer_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["leading_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["remove_private_asmode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.IgnorePeerAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ignore_peer_as"] = val

		val, err = v.LeadingOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["leading_only"] = val

		val, err = v.RemovePrivateAsmode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove_private_asmode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemovePrivateAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemovePrivateAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemovePrivateAsValue) String() string {
	return "RemovePrivateAsValue"
}

func (v RemovePrivateAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ignore_peer_as":        basetypes.BoolType{},
		"leading_only":          basetypes.BoolType{},
		"remove_private_asmode": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ignore_peer_as":        v.IgnorePeerAs,
			"leading_only":          v.LeadingOnly,
			"remove_private_asmode": v.RemovePrivateAsmode,
		})

	return objVal, diags
}

func (v RemovePrivateAsValue) Equal(o attr.Value) bool {
	other, ok := o.(RemovePrivateAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IgnorePeerAs.Equal(other.IgnorePeerAs) {
		return false
	}

	if !v.LeadingOnly.Equal(other.LeadingOnly) {
		return false
	}

	if !v.RemovePrivateAsmode.Equal(other.RemovePrivateAsmode) {
		return false
	}

	return true
}

func (v RemovePrivateAsValue) Type(ctx context.Context) attr.Type {
	return RemovePrivateAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemovePrivateAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ignore_peer_as":        basetypes.BoolType{},
		"leading_only":          basetypes.BoolType{},
		"remove_private_asmode": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4unicastType{}

type Ipv4unicastType struct {
	basetypes.ObjectType
}

func (t Ipv4unicastType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4unicastType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4unicastType) String() string {
	return "Ipv4unicastType"
}

func (t Ipv4unicastType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertiseIpv6nextHopsAttribute, ok := attributes["advertise_ipv6next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6next_hops is missing from object`)

		return nil, diags
	}

	advertiseIpv6nextHopsVal, ok := advertiseIpv6nextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6nextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimitAttribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit is missing from object`)

		return nil, diags
	}

	prefixLimitVal, ok := prefixLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit expected to be basetypes.ObjectValue, was: %T`, prefixLimitAttribute))
	}

	receiveIpv6nextHopsAttribute, ok := attributes["receive_ipv6next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6next_hops is missing from object`)

		return nil, diags
	}

	receiveIpv6nextHopsVal, ok := receiveIpv6nextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6nextHopsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4unicastValue{
		AdvertiseIpv6nextHops: advertiseIpv6nextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit:           prefixLimitVal,
		ReceiveIpv6nextHops:   receiveIpv6nextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4unicastValueNull() Ipv4unicastValue {
	return Ipv4unicastValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4unicastValueUnknown() Ipv4unicastValue {
	return Ipv4unicastValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4unicastValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4unicastValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4unicastValue Attribute Value",
				"While creating a Ipv4unicastValue value, a missing attribute value was detected. "+
					"A Ipv4unicastValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4unicastValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4unicastValue Attribute Type",
				"While creating a Ipv4unicastValue value, an invalid attribute value was detected. "+
					"A Ipv4unicastValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4unicastValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4unicastValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4unicastValue Attribute Value",
				"While creating a Ipv4unicastValue value, an extra attribute value was detected. "+
					"A Ipv4unicastValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4unicastValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4unicastValueUnknown(), diags
	}

	advertiseIpv6nextHopsAttribute, ok := attributes["advertise_ipv6next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6next_hops is missing from object`)

		return NewIpv4unicastValueUnknown(), diags
	}

	advertiseIpv6nextHopsVal, ok := advertiseIpv6nextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6nextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv4unicastValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimitAttribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit is missing from object`)

		return NewIpv4unicastValueUnknown(), diags
	}

	prefixLimitVal, ok := prefixLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit expected to be basetypes.ObjectValue, was: %T`, prefixLimitAttribute))
	}

	receiveIpv6nextHopsAttribute, ok := attributes["receive_ipv6next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6next_hops is missing from object`)

		return NewIpv4unicastValueUnknown(), diags
	}

	receiveIpv6nextHopsVal, ok := receiveIpv6nextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6nextHopsAttribute))
	}

	if diags.HasError() {
		return NewIpv4unicastValueUnknown(), diags
	}

	return Ipv4unicastValue{
		AdvertiseIpv6nextHops: advertiseIpv6nextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit:           prefixLimitVal,
		ReceiveIpv6nextHops:   receiveIpv6nextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4unicastValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4unicastValue {
	object, diags := NewIpv4unicastValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4unicastValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4unicastType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4unicastValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4unicastValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4unicastValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4unicastValueMust(Ipv4unicastValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4unicastType) ValueType(ctx context.Context) attr.Value {
	return Ipv4unicastValue{}
}

var _ basetypes.ObjectValuable = Ipv4unicastValue{}

type Ipv4unicastValue struct {
	AdvertiseIpv6nextHops basetypes.BoolValue   `tfsdk:"advertise_ipv6next_hops"`
	Enabled               basetypes.BoolValue   `tfsdk:"enabled"`
	PrefixLimit           basetypes.ObjectValue `tfsdk:"prefix_limit"`
	ReceiveIpv6nextHops   basetypes.BoolValue   `tfsdk:"receive_ipv6next_hops"`
	state                 attr.ValueState
}

func (v Ipv4unicastValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["advertise_ipv6next_hops"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix_limit"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["receive_ipv6next_hops"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdvertiseIpv6nextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertise_ipv6next_hops"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.PrefixLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit"] = val

		val, err = v.ReceiveIpv6nextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["receive_ipv6next_hops"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4unicastValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4unicastValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4unicastValue) String() string {
	return "Ipv4unicastValue"
}

func (v Ipv4unicastValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimit basetypes.ObjectValue

	if v.PrefixLimit.IsNull() {
		prefixLimit = types.ObjectNull(
			PrefixLimitValue{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimit.IsUnknown() {
		prefixLimit = types.ObjectUnknown(
			PrefixLimitValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimit.IsNull() && !v.PrefixLimit.IsUnknown() {
		prefixLimit = types.ObjectValueMust(
			PrefixLimitValue{}.AttributeTypes(ctx),
			v.PrefixLimit.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"advertise_ipv6next_hops": basetypes.BoolType{},
		"enabled":                 basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
		},
		"receive_ipv6next_hops": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertise_ipv6next_hops": v.AdvertiseIpv6nextHops,
			"enabled":                 v.Enabled,
			"prefix_limit":            prefixLimit,
			"receive_ipv6next_hops":   v.ReceiveIpv6nextHops,
		})

	return objVal, diags
}

func (v Ipv4unicastValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4unicastValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertiseIpv6nextHops.Equal(other.AdvertiseIpv6nextHops) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.PrefixLimit.Equal(other.PrefixLimit) {
		return false
	}

	if !v.ReceiveIpv6nextHops.Equal(other.ReceiveIpv6nextHops) {
		return false
	}

	return true
}

func (v Ipv4unicastValue) Type(ctx context.Context) attr.Type {
	return Ipv4unicastType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4unicastValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertise_ipv6next_hops": basetypes.BoolType{},
		"enabled":                 basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
		},
		"receive_ipv6next_hops": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitType{}

type PrefixLimitType struct {
	basetypes.ObjectType
}

func (t PrefixLimitType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitType) String() string {
	return "PrefixLimitType"
}

func (t PrefixLimitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixLimitAcceptedAttribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted is missing from object`)

		return nil, diags
	}

	prefixLimitAcceptedVal, ok := prefixLimitAcceptedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted expected to be basetypes.ObjectValue, was: %T`, prefixLimitAcceptedAttribute))
	}

	prefixLimitReceivedAttribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received is missing from object`)

		return nil, diags
	}

	prefixLimitReceivedVal, ok := prefixLimitReceivedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceivedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitValue{
		PrefixLimitAccepted: prefixLimitAcceptedVal,
		PrefixLimitReceived: prefixLimitReceivedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitValueNull() PrefixLimitValue {
	return PrefixLimitValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitValueUnknown() PrefixLimitValue {
	return PrefixLimitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitValue Attribute Value",
				"While creating a PrefixLimitValue value, a missing attribute value was detected. "+
					"A PrefixLimitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitValue Attribute Type",
				"While creating a PrefixLimitValue value, an invalid attribute value was detected. "+
					"A PrefixLimitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitValue Attribute Value",
				"While creating a PrefixLimitValue value, an extra attribute value was detected. "+
					"A PrefixLimitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitValueUnknown(), diags
	}

	prefixLimitAcceptedAttribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted is missing from object`)

		return NewPrefixLimitValueUnknown(), diags
	}

	prefixLimitAcceptedVal, ok := prefixLimitAcceptedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted expected to be basetypes.ObjectValue, was: %T`, prefixLimitAcceptedAttribute))
	}

	prefixLimitReceivedAttribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received is missing from object`)

		return NewPrefixLimitValueUnknown(), diags
	}

	prefixLimitReceivedVal, ok := prefixLimitReceivedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceivedAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitValueUnknown(), diags
	}

	return PrefixLimitValue{
		PrefixLimitAccepted: prefixLimitAcceptedVal,
		PrefixLimitReceived: prefixLimitReceivedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitValue {
	object, diags := NewPrefixLimitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitValueMust(PrefixLimitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitType) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitValue{}
}

var _ basetypes.ObjectValuable = PrefixLimitValue{}

type PrefixLimitValue struct {
	PrefixLimitAccepted basetypes.ObjectValue `tfsdk:"prefix_limit_accepted"`
	PrefixLimitReceived basetypes.ObjectValue `tfsdk:"prefix_limit_received"`
	state               attr.ValueState
}

func (v PrefixLimitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["prefix_limit_accepted"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_limit_received"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PrefixLimitAccepted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_accepted"] = val

		val, err = v.PrefixLimitReceived.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_received"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitValue) String() string {
	return "PrefixLimitValue"
}

func (v PrefixLimitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimitAccepted basetypes.ObjectValue

	if v.PrefixLimitAccepted.IsNull() {
		prefixLimitAccepted = types.ObjectNull(
			PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitAccepted.IsUnknown() {
		prefixLimitAccepted = types.ObjectUnknown(
			PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitAccepted.IsNull() && !v.PrefixLimitAccepted.IsUnknown() {
		prefixLimitAccepted = types.ObjectValueMust(
			PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
			v.PrefixLimitAccepted.Attributes(),
		)
	}

	var prefixLimitReceived basetypes.ObjectValue

	if v.PrefixLimitReceived.IsNull() {
		prefixLimitReceived = types.ObjectNull(
			PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitReceived.IsUnknown() {
		prefixLimitReceived = types.ObjectUnknown(
			PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitReceived.IsNull() && !v.PrefixLimitReceived.IsUnknown() {
		prefixLimitReceived = types.ObjectValueMust(
			PrefixLimitReceivedValue{}.AttributeTypes(ctx),
			v.PrefixLimitReceived.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix_limit_accepted": prefixLimitAccepted,
			"prefix_limit_received": prefixLimitReceived,
		})

	return objVal, diags
}

func (v PrefixLimitValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PrefixLimitAccepted.Equal(other.PrefixLimitAccepted) {
		return false
	}

	if !v.PrefixLimitReceived.Equal(other.PrefixLimitReceived) {
		return false
	}

	return true
}

func (v PrefixLimitValue) Type(ctx context.Context) attr.Type {
	return PrefixLimitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitAcceptedType{}

type PrefixLimitAcceptedType struct {
	basetypes.ObjectType
}

func (t PrefixLimitAcceptedType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitAcceptedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitAcceptedType) String() string {
	return "PrefixLimitAcceptedType"
}

func (t PrefixLimitAcceptedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitAcceptedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAcceptedValueNull() PrefixLimitAcceptedValue {
	return PrefixLimitAcceptedValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitAcceptedValueUnknown() PrefixLimitAcceptedValue {
	return PrefixLimitAcceptedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitAcceptedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitAcceptedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitAcceptedValue Attribute Value",
				"While creating a PrefixLimitAcceptedValue value, a missing attribute value was detected. "+
					"A PrefixLimitAcceptedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAcceptedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitAcceptedValue Attribute Type",
				"While creating a PrefixLimitAcceptedValue value, an invalid attribute value was detected. "+
					"A PrefixLimitAcceptedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAcceptedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitAcceptedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitAcceptedValue Attribute Value",
				"While creating a PrefixLimitAcceptedValue value, an extra attribute value was detected. "+
					"A PrefixLimitAcceptedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitAcceptedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	return PrefixLimitAcceptedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAcceptedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitAcceptedValue {
	object, diags := NewPrefixLimitAcceptedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitAcceptedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitAcceptedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitAcceptedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitAcceptedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitAcceptedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitAcceptedValueMust(PrefixLimitAcceptedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitAcceptedType) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitAcceptedValue{}
}

var _ basetypes.ObjectValuable = PrefixLimitAcceptedValue{}

type PrefixLimitAcceptedValue struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitAcceptedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitAcceptedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitAcceptedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitAcceptedValue) String() string {
	return "PrefixLimitAcceptedValue"
}

func (v PrefixLimitAcceptedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitAcceptedValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitAcceptedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitAcceptedValue) Type(ctx context.Context) attr.Type {
	return PrefixLimitAcceptedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitAcceptedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitReceivedType{}

type PrefixLimitReceivedType struct {
	basetypes.ObjectType
}

func (t PrefixLimitReceivedType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitReceivedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitReceivedType) String() string {
	return "PrefixLimitReceivedType"
}

func (t PrefixLimitReceivedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitReceivedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceivedValueNull() PrefixLimitReceivedValue {
	return PrefixLimitReceivedValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitReceivedValueUnknown() PrefixLimitReceivedValue {
	return PrefixLimitReceivedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitReceivedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitReceivedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitReceivedValue Attribute Value",
				"While creating a PrefixLimitReceivedValue value, a missing attribute value was detected. "+
					"A PrefixLimitReceivedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceivedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitReceivedValue Attribute Type",
				"While creating a PrefixLimitReceivedValue value, an invalid attribute value was detected. "+
					"A PrefixLimitReceivedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceivedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitReceivedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitReceivedValue Attribute Value",
				"While creating a PrefixLimitReceivedValue value, an extra attribute value was detected. "+
					"A PrefixLimitReceivedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitReceivedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	return PrefixLimitReceivedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceivedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitReceivedValue {
	object, diags := NewPrefixLimitReceivedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitReceivedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitReceivedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitReceivedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitReceivedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitReceivedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitReceivedValueMust(PrefixLimitReceivedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitReceivedType) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitReceivedValue{}
}

var _ basetypes.ObjectValuable = PrefixLimitReceivedValue{}

type PrefixLimitReceivedValue struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitReceivedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitReceivedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitReceivedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitReceivedValue) String() string {
	return "PrefixLimitReceivedValue"
}

func (v PrefixLimitReceivedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitReceivedValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitReceivedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitReceivedValue) Type(ctx context.Context) attr.Type {
	return PrefixLimitReceivedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitReceivedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Ipv6unicastType{}

type Ipv6unicastType struct {
	basetypes.ObjectType
}

func (t Ipv6unicastType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6unicastType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6unicastType) String() string {
	return "Ipv6unicastType"
}

func (t Ipv6unicastType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit1Attribute, ok := attributes["prefix_limit_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_1 is missing from object`)

		return nil, diags
	}

	prefixLimit1Val, ok := prefixLimit1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimit1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6unicastValue{
		Enabled:      enabledVal,
		PrefixLimit1: prefixLimit1Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpv6unicastValueNull() Ipv6unicastValue {
	return Ipv6unicastValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6unicastValueUnknown() Ipv6unicastValue {
	return Ipv6unicastValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6unicastValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6unicastValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6unicastValue Attribute Value",
				"While creating a Ipv6unicastValue value, a missing attribute value was detected. "+
					"A Ipv6unicastValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6unicastValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6unicastValue Attribute Type",
				"While creating a Ipv6unicastValue value, an invalid attribute value was detected. "+
					"A Ipv6unicastValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6unicastValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6unicastValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6unicastValue Attribute Value",
				"While creating a Ipv6unicastValue value, an extra attribute value was detected. "+
					"A Ipv6unicastValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6unicastValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6unicastValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv6unicastValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit1Attribute, ok := attributes["prefix_limit_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_1 is missing from object`)

		return NewIpv6unicastValueUnknown(), diags
	}

	prefixLimit1Val, ok := prefixLimit1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimit1Attribute))
	}

	if diags.HasError() {
		return NewIpv6unicastValueUnknown(), diags
	}

	return Ipv6unicastValue{
		Enabled:      enabledVal,
		PrefixLimit1: prefixLimit1Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpv6unicastValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6unicastValue {
	object, diags := NewIpv6unicastValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6unicastValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6unicastType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6unicastValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6unicastValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6unicastValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6unicastValueMust(Ipv6unicastValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6unicastType) ValueType(ctx context.Context) attr.Value {
	return Ipv6unicastValue{}
}

var _ basetypes.ObjectValuable = Ipv6unicastValue{}

type Ipv6unicastValue struct {
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	PrefixLimit1 basetypes.ObjectValue `tfsdk:"prefix_limit_1"`
	state        attr.ValueState
}

func (v Ipv6unicastValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix_limit_1"] = basetypes.ObjectType{
		AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.PrefixLimit1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_1"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6unicastValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6unicastValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6unicastValue) String() string {
	return "Ipv6unicastValue"
}

func (v Ipv6unicastValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimit1 basetypes.ObjectValue

	if v.PrefixLimit1.IsNull() {
		prefixLimit1 = types.ObjectNull(
			PrefixLimit1Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimit1.IsUnknown() {
		prefixLimit1 = types.ObjectUnknown(
			PrefixLimit1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimit1.IsNull() && !v.PrefixLimit1.IsUnknown() {
		prefixLimit1 = types.ObjectValueMust(
			PrefixLimit1Value{}.AttributeTypes(ctx),
			v.PrefixLimit1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"prefix_limit_1": basetypes.ObjectType{
			AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":        v.Enabled,
			"prefix_limit_1": prefixLimit1,
		})

	return objVal, diags
}

func (v Ipv6unicastValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6unicastValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.PrefixLimit1.Equal(other.PrefixLimit1) {
		return false
	}

	return true
}

func (v Ipv6unicastValue) Type(ctx context.Context) attr.Type {
	return Ipv6unicastType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6unicastValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"prefix_limit_1": basetypes.ObjectType{
			AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimit1Type{}

type PrefixLimit1Type struct {
	basetypes.ObjectType
}

func (t PrefixLimit1Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimit1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimit1Type) String() string {
	return "PrefixLimit1Type"
}

func (t PrefixLimit1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixLimitAccepted1Attribute, ok := attributes["prefix_limit_accepted_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_1 is missing from object`)

		return nil, diags
	}

	prefixLimitAccepted1Val, ok := prefixLimitAccepted1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted1Attribute))
	}

	prefixLimitReceived1Attribute, ok := attributes["prefix_limit_received_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_1 is missing from object`)

		return nil, diags
	}

	prefixLimitReceived1Val, ok := prefixLimitReceived1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimit1Value{
		PrefixLimitAccepted1: prefixLimitAccepted1Val,
		PrefixLimitReceived1: prefixLimitReceived1Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit1ValueNull() PrefixLimit1Value {
	return PrefixLimit1Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimit1ValueUnknown() PrefixLimit1Value {
	return PrefixLimit1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimit1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimit1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimit1Value Attribute Value",
				"While creating a PrefixLimit1Value value, a missing attribute value was detected. "+
					"A PrefixLimit1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimit1Value Attribute Type",
				"While creating a PrefixLimit1Value value, an invalid attribute value was detected. "+
					"A PrefixLimit1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimit1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimit1Value Attribute Value",
				"While creating a PrefixLimit1Value value, an extra attribute value was detected. "+
					"A PrefixLimit1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimit1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimit1ValueUnknown(), diags
	}

	prefixLimitAccepted1Attribute, ok := attributes["prefix_limit_accepted_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_1 is missing from object`)

		return NewPrefixLimit1ValueUnknown(), diags
	}

	prefixLimitAccepted1Val, ok := prefixLimitAccepted1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted1Attribute))
	}

	prefixLimitReceived1Attribute, ok := attributes["prefix_limit_received_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_1 is missing from object`)

		return NewPrefixLimit1ValueUnknown(), diags
	}

	prefixLimitReceived1Val, ok := prefixLimitReceived1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived1Attribute))
	}

	if diags.HasError() {
		return NewPrefixLimit1ValueUnknown(), diags
	}

	return PrefixLimit1Value{
		PrefixLimitAccepted1: prefixLimitAccepted1Val,
		PrefixLimitReceived1: prefixLimitReceived1Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimit1Value {
	object, diags := NewPrefixLimit1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimit1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimit1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimit1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimit1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimit1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimit1ValueMust(PrefixLimit1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimit1Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimit1Value{}
}

var _ basetypes.ObjectValuable = PrefixLimit1Value{}

type PrefixLimit1Value struct {
	PrefixLimitAccepted1 basetypes.ObjectValue `tfsdk:"prefix_limit_accepted_1"`
	PrefixLimitReceived1 basetypes.ObjectValue `tfsdk:"prefix_limit_received_1"`
	state                attr.ValueState
}

func (v PrefixLimit1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["prefix_limit_accepted_1"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_limit_received_1"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PrefixLimitAccepted1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_accepted_1"] = val

		val, err = v.PrefixLimitReceived1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_received_1"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimit1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimit1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimit1Value) String() string {
	return "PrefixLimit1Value"
}

func (v PrefixLimit1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimitAccepted1 basetypes.ObjectValue

	if v.PrefixLimitAccepted1.IsNull() {
		prefixLimitAccepted1 = types.ObjectNull(
			PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitAccepted1.IsUnknown() {
		prefixLimitAccepted1 = types.ObjectUnknown(
			PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitAccepted1.IsNull() && !v.PrefixLimitAccepted1.IsUnknown() {
		prefixLimitAccepted1 = types.ObjectValueMust(
			PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
			v.PrefixLimitAccepted1.Attributes(),
		)
	}

	var prefixLimitReceived1 basetypes.ObjectValue

	if v.PrefixLimitReceived1.IsNull() {
		prefixLimitReceived1 = types.ObjectNull(
			PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitReceived1.IsUnknown() {
		prefixLimitReceived1 = types.ObjectUnknown(
			PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitReceived1.IsNull() && !v.PrefixLimitReceived1.IsUnknown() {
		prefixLimitReceived1 = types.ObjectValueMust(
			PrefixLimitReceived1Value{}.AttributeTypes(ctx),
			v.PrefixLimitReceived1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix_limit_accepted_1": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received_1": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix_limit_accepted_1": prefixLimitAccepted1,
			"prefix_limit_received_1": prefixLimitReceived1,
		})

	return objVal, diags
}

func (v PrefixLimit1Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimit1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PrefixLimitAccepted1.Equal(other.PrefixLimitAccepted1) {
		return false
	}

	if !v.PrefixLimitReceived1.Equal(other.PrefixLimitReceived1) {
		return false
	}

	return true
}

func (v PrefixLimit1Value) Type(ctx context.Context) attr.Type {
	return PrefixLimit1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimit1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix_limit_accepted_1": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received_1": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitAccepted1Type{}

type PrefixLimitAccepted1Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitAccepted1Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitAccepted1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitAccepted1Type) String() string {
	return "PrefixLimitAccepted1Type"
}

func (t PrefixLimitAccepted1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitAccepted1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted1ValueNull() PrefixLimitAccepted1Value {
	return PrefixLimitAccepted1Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitAccepted1ValueUnknown() PrefixLimitAccepted1Value {
	return PrefixLimitAccepted1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitAccepted1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitAccepted1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitAccepted1Value Attribute Value",
				"While creating a PrefixLimitAccepted1Value value, a missing attribute value was detected. "+
					"A PrefixLimitAccepted1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitAccepted1Value Attribute Type",
				"While creating a PrefixLimitAccepted1Value value, an invalid attribute value was detected. "+
					"A PrefixLimitAccepted1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitAccepted1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitAccepted1Value Attribute Value",
				"While creating a PrefixLimitAccepted1Value value, an extra attribute value was detected. "+
					"A PrefixLimitAccepted1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitAccepted1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	return PrefixLimitAccepted1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitAccepted1Value {
	object, diags := NewPrefixLimitAccepted1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitAccepted1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitAccepted1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitAccepted1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitAccepted1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitAccepted1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitAccepted1ValueMust(PrefixLimitAccepted1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitAccepted1Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitAccepted1Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitAccepted1Value{}

type PrefixLimitAccepted1Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitAccepted1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitAccepted1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitAccepted1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitAccepted1Value) String() string {
	return "PrefixLimitAccepted1Value"
}

func (v PrefixLimitAccepted1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitAccepted1Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitAccepted1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitAccepted1Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitAccepted1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitAccepted1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitReceived1Type{}

type PrefixLimitReceived1Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitReceived1Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitReceived1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitReceived1Type) String() string {
	return "PrefixLimitReceived1Type"
}

func (t PrefixLimitReceived1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitReceived1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived1ValueNull() PrefixLimitReceived1Value {
	return PrefixLimitReceived1Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitReceived1ValueUnknown() PrefixLimitReceived1Value {
	return PrefixLimitReceived1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitReceived1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitReceived1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitReceived1Value Attribute Value",
				"While creating a PrefixLimitReceived1Value value, a missing attribute value was detected. "+
					"A PrefixLimitReceived1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitReceived1Value Attribute Type",
				"While creating a PrefixLimitReceived1Value value, an invalid attribute value was detected. "+
					"A PrefixLimitReceived1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitReceived1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitReceived1Value Attribute Value",
				"While creating a PrefixLimitReceived1Value value, an extra attribute value was detected. "+
					"A PrefixLimitReceived1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitReceived1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	return PrefixLimitReceived1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitReceived1Value {
	object, diags := NewPrefixLimitReceived1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitReceived1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitReceived1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitReceived1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitReceived1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitReceived1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitReceived1ValueMust(PrefixLimitReceived1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitReceived1Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitReceived1Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitReceived1Value{}

type PrefixLimitReceived1Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitReceived1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitReceived1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitReceived1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitReceived1Value) String() string {
	return "PrefixLimitReceived1Value"
}

func (v PrefixLimitReceived1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitReceived1Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitReceived1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitReceived1Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitReceived1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitReceived1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = L2vpnevpnType{}

type L2vpnevpnType struct {
	basetypes.ObjectType
}

func (t L2vpnevpnType) Equal(o attr.Type) bool {
	other, ok := o.(L2vpnevpnType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L2vpnevpnType) String() string {
	return "L2vpnevpnType"
}

func (t L2vpnevpnType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertiseIpv6nextHopsAttribute, ok := attributes["advertise_ipv6next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6next_hops is missing from object`)

		return nil, diags
	}

	advertiseIpv6nextHopsVal, ok := advertiseIpv6nextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6nextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit2Attribute, ok := attributes["prefix_limit_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_2 is missing from object`)

		return nil, diags
	}

	prefixLimit2Val, ok := prefixLimit2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimit2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L2vpnevpnValue{
		AdvertiseIpv6nextHops: advertiseIpv6nextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit2:          prefixLimit2Val,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewL2vpnevpnValueNull() L2vpnevpnValue {
	return L2vpnevpnValue{
		state: attr.ValueStateNull,
	}
}

func NewL2vpnevpnValueUnknown() L2vpnevpnValue {
	return L2vpnevpnValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL2vpnevpnValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L2vpnevpnValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L2vpnevpnValue Attribute Value",
				"While creating a L2vpnevpnValue value, a missing attribute value was detected. "+
					"A L2vpnevpnValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L2vpnevpnValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L2vpnevpnValue Attribute Type",
				"While creating a L2vpnevpnValue value, an invalid attribute value was detected. "+
					"A L2vpnevpnValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L2vpnevpnValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L2vpnevpnValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L2vpnevpnValue Attribute Value",
				"While creating a L2vpnevpnValue value, an extra attribute value was detected. "+
					"A L2vpnevpnValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L2vpnevpnValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL2vpnevpnValueUnknown(), diags
	}

	advertiseIpv6nextHopsAttribute, ok := attributes["advertise_ipv6next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6next_hops is missing from object`)

		return NewL2vpnevpnValueUnknown(), diags
	}

	advertiseIpv6nextHopsVal, ok := advertiseIpv6nextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6nextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewL2vpnevpnValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit2Attribute, ok := attributes["prefix_limit_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_2 is missing from object`)

		return NewL2vpnevpnValueUnknown(), diags
	}

	prefixLimit2Val, ok := prefixLimit2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimit2Attribute))
	}

	if diags.HasError() {
		return NewL2vpnevpnValueUnknown(), diags
	}

	return L2vpnevpnValue{
		AdvertiseIpv6nextHops: advertiseIpv6nextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit2:          prefixLimit2Val,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewL2vpnevpnValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L2vpnevpnValue {
	object, diags := NewL2vpnevpnValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL2vpnevpnValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L2vpnevpnType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL2vpnevpnValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL2vpnevpnValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL2vpnevpnValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL2vpnevpnValueMust(L2vpnevpnValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L2vpnevpnType) ValueType(ctx context.Context) attr.Value {
	return L2vpnevpnValue{}
}

var _ basetypes.ObjectValuable = L2vpnevpnValue{}

type L2vpnevpnValue struct {
	AdvertiseIpv6nextHops basetypes.BoolValue   `tfsdk:"advertise_ipv6next_hops"`
	Enabled               basetypes.BoolValue   `tfsdk:"enabled"`
	PrefixLimit2          basetypes.ObjectValue `tfsdk:"prefix_limit_2"`
	state                 attr.ValueState
}

func (v L2vpnevpnValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["advertise_ipv6next_hops"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix_limit_2"] = basetypes.ObjectType{
		AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AdvertiseIpv6nextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertise_ipv6next_hops"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.PrefixLimit2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_2"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L2vpnevpnValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L2vpnevpnValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L2vpnevpnValue) String() string {
	return "L2vpnevpnValue"
}

func (v L2vpnevpnValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimit2 basetypes.ObjectValue

	if v.PrefixLimit2.IsNull() {
		prefixLimit2 = types.ObjectNull(
			PrefixLimit2Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimit2.IsUnknown() {
		prefixLimit2 = types.ObjectUnknown(
			PrefixLimit2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimit2.IsNull() && !v.PrefixLimit2.IsUnknown() {
		prefixLimit2 = types.ObjectValueMust(
			PrefixLimit2Value{}.AttributeTypes(ctx),
			v.PrefixLimit2.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"advertise_ipv6next_hops": basetypes.BoolType{},
		"enabled":                 basetypes.BoolType{},
		"prefix_limit_2": basetypes.ObjectType{
			AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertise_ipv6next_hops": v.AdvertiseIpv6nextHops,
			"enabled":                 v.Enabled,
			"prefix_limit_2":          prefixLimit2,
		})

	return objVal, diags
}

func (v L2vpnevpnValue) Equal(o attr.Value) bool {
	other, ok := o.(L2vpnevpnValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertiseIpv6nextHops.Equal(other.AdvertiseIpv6nextHops) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.PrefixLimit2.Equal(other.PrefixLimit2) {
		return false
	}

	return true
}

func (v L2vpnevpnValue) Type(ctx context.Context) attr.Type {
	return L2vpnevpnType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L2vpnevpnValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertise_ipv6next_hops": basetypes.BoolType{},
		"enabled":                 basetypes.BoolType{},
		"prefix_limit_2": basetypes.ObjectType{
			AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimit2Type{}

type PrefixLimit2Type struct {
	basetypes.ObjectType
}

func (t PrefixLimit2Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimit2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimit2Type) String() string {
	return "PrefixLimit2Type"
}

func (t PrefixLimit2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixLimitAccepted2Attribute, ok := attributes["prefix_limit_accepted_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_2 is missing from object`)

		return nil, diags
	}

	prefixLimitAccepted2Val, ok := prefixLimitAccepted2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted2Attribute))
	}

	prefixLimitReceived2Attribute, ok := attributes["prefix_limit_received_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_2 is missing from object`)

		return nil, diags
	}

	prefixLimitReceived2Val, ok := prefixLimitReceived2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimit2Value{
		PrefixLimitAccepted2: prefixLimitAccepted2Val,
		PrefixLimitReceived2: prefixLimitReceived2Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit2ValueNull() PrefixLimit2Value {
	return PrefixLimit2Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimit2ValueUnknown() PrefixLimit2Value {
	return PrefixLimit2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimit2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimit2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimit2Value Attribute Value",
				"While creating a PrefixLimit2Value value, a missing attribute value was detected. "+
					"A PrefixLimit2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimit2Value Attribute Type",
				"While creating a PrefixLimit2Value value, an invalid attribute value was detected. "+
					"A PrefixLimit2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimit2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimit2Value Attribute Value",
				"While creating a PrefixLimit2Value value, an extra attribute value was detected. "+
					"A PrefixLimit2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimit2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimit2ValueUnknown(), diags
	}

	prefixLimitAccepted2Attribute, ok := attributes["prefix_limit_accepted_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_2 is missing from object`)

		return NewPrefixLimit2ValueUnknown(), diags
	}

	prefixLimitAccepted2Val, ok := prefixLimitAccepted2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted2Attribute))
	}

	prefixLimitReceived2Attribute, ok := attributes["prefix_limit_received_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_2 is missing from object`)

		return NewPrefixLimit2ValueUnknown(), diags
	}

	prefixLimitReceived2Val, ok := prefixLimitReceived2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived2Attribute))
	}

	if diags.HasError() {
		return NewPrefixLimit2ValueUnknown(), diags
	}

	return PrefixLimit2Value{
		PrefixLimitAccepted2: prefixLimitAccepted2Val,
		PrefixLimitReceived2: prefixLimitReceived2Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimit2Value {
	object, diags := NewPrefixLimit2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimit2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimit2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimit2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimit2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimit2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimit2ValueMust(PrefixLimit2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimit2Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimit2Value{}
}

var _ basetypes.ObjectValuable = PrefixLimit2Value{}

type PrefixLimit2Value struct {
	PrefixLimitAccepted2 basetypes.ObjectValue `tfsdk:"prefix_limit_accepted_2"`
	PrefixLimitReceived2 basetypes.ObjectValue `tfsdk:"prefix_limit_received_2"`
	state                attr.ValueState
}

func (v PrefixLimit2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["prefix_limit_accepted_2"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_limit_received_2"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PrefixLimitAccepted2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_accepted_2"] = val

		val, err = v.PrefixLimitReceived2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_received_2"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimit2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimit2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimit2Value) String() string {
	return "PrefixLimit2Value"
}

func (v PrefixLimit2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimitAccepted2 basetypes.ObjectValue

	if v.PrefixLimitAccepted2.IsNull() {
		prefixLimitAccepted2 = types.ObjectNull(
			PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitAccepted2.IsUnknown() {
		prefixLimitAccepted2 = types.ObjectUnknown(
			PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitAccepted2.IsNull() && !v.PrefixLimitAccepted2.IsUnknown() {
		prefixLimitAccepted2 = types.ObjectValueMust(
			PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
			v.PrefixLimitAccepted2.Attributes(),
		)
	}

	var prefixLimitReceived2 basetypes.ObjectValue

	if v.PrefixLimitReceived2.IsNull() {
		prefixLimitReceived2 = types.ObjectNull(
			PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitReceived2.IsUnknown() {
		prefixLimitReceived2 = types.ObjectUnknown(
			PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitReceived2.IsNull() && !v.PrefixLimitReceived2.IsUnknown() {
		prefixLimitReceived2 = types.ObjectValueMust(
			PrefixLimitReceived2Value{}.AttributeTypes(ctx),
			v.PrefixLimitReceived2.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix_limit_accepted_2": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received_2": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix_limit_accepted_2": prefixLimitAccepted2,
			"prefix_limit_received_2": prefixLimitReceived2,
		})

	return objVal, diags
}

func (v PrefixLimit2Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimit2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PrefixLimitAccepted2.Equal(other.PrefixLimitAccepted2) {
		return false
	}

	if !v.PrefixLimitReceived2.Equal(other.PrefixLimitReceived2) {
		return false
	}

	return true
}

func (v PrefixLimit2Value) Type(ctx context.Context) attr.Type {
	return PrefixLimit2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimit2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix_limit_accepted_2": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received_2": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitAccepted2Type{}

type PrefixLimitAccepted2Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitAccepted2Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitAccepted2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitAccepted2Type) String() string {
	return "PrefixLimitAccepted2Type"
}

func (t PrefixLimitAccepted2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitAccepted2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted2ValueNull() PrefixLimitAccepted2Value {
	return PrefixLimitAccepted2Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitAccepted2ValueUnknown() PrefixLimitAccepted2Value {
	return PrefixLimitAccepted2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitAccepted2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitAccepted2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitAccepted2Value Attribute Value",
				"While creating a PrefixLimitAccepted2Value value, a missing attribute value was detected. "+
					"A PrefixLimitAccepted2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitAccepted2Value Attribute Type",
				"While creating a PrefixLimitAccepted2Value value, an invalid attribute value was detected. "+
					"A PrefixLimitAccepted2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitAccepted2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitAccepted2Value Attribute Value",
				"While creating a PrefixLimitAccepted2Value value, an extra attribute value was detected. "+
					"A PrefixLimitAccepted2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitAccepted2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	return PrefixLimitAccepted2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitAccepted2Value {
	object, diags := NewPrefixLimitAccepted2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitAccepted2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitAccepted2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitAccepted2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitAccepted2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitAccepted2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitAccepted2ValueMust(PrefixLimitAccepted2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitAccepted2Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitAccepted2Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitAccepted2Value{}

type PrefixLimitAccepted2Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitAccepted2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitAccepted2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitAccepted2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitAccepted2Value) String() string {
	return "PrefixLimitAccepted2Value"
}

func (v PrefixLimitAccepted2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitAccepted2Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitAccepted2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitAccepted2Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitAccepted2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitAccepted2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitReceived2Type{}

type PrefixLimitReceived2Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitReceived2Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitReceived2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitReceived2Type) String() string {
	return "PrefixLimitReceived2Type"
}

func (t PrefixLimitReceived2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitReceived2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived2ValueNull() PrefixLimitReceived2Value {
	return PrefixLimitReceived2Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitReceived2ValueUnknown() PrefixLimitReceived2Value {
	return PrefixLimitReceived2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitReceived2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitReceived2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitReceived2Value Attribute Value",
				"While creating a PrefixLimitReceived2Value value, a missing attribute value was detected. "+
					"A PrefixLimitReceived2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitReceived2Value Attribute Type",
				"While creating a PrefixLimitReceived2Value value, an invalid attribute value was detected. "+
					"A PrefixLimitReceived2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitReceived2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitReceived2Value Attribute Value",
				"While creating a PrefixLimitReceived2Value value, an extra attribute value was detected. "+
					"A PrefixLimitReceived2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitReceived2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	return PrefixLimitReceived2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitReceived2Value {
	object, diags := NewPrefixLimitReceived2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitReceived2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitReceived2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitReceived2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitReceived2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitReceived2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitReceived2ValueMust(PrefixLimitReceived2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitReceived2Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitReceived2Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitReceived2Value{}

type PrefixLimitReceived2Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitReceived2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitReceived2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitReceived2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitReceived2Value) String() string {
	return "PrefixLimitReceived2Value"
}

func (v PrefixLimitReceived2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitReceived2Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitReceived2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitReceived2Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitReceived2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitReceived2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LocalAsType{}

type LocalAsType struct {
	basetypes.ObjectType
}

func (t LocalAsType) Equal(o attr.Type) bool {
	other, ok := o.(LocalAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalAsType) String() string {
	return "LocalAsType"
}

func (t LocalAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return nil, diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	prependGlobalAsAttribute, ok := attributes["prepend_global_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_global_as is missing from object`)

		return nil, diags
	}

	prependGlobalAsVal, ok := prependGlobalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_global_as expected to be basetypes.BoolValue, was: %T`, prependGlobalAsAttribute))
	}

	prependLocalAsAttribute, ok := attributes["prepend_local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_local_as is missing from object`)

		return nil, diags
	}

	prependLocalAsVal, ok := prependLocalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_local_as expected to be basetypes.BoolValue, was: %T`, prependLocalAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalAsValue{
		AutonomousSystem: autonomousSystemVal,
		PrependGlobalAs:  prependGlobalAsVal,
		PrependLocalAs:   prependLocalAsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalAsValueNull() LocalAsValue {
	return LocalAsValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalAsValueUnknown() LocalAsValue {
	return LocalAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalAsValue Attribute Value",
				"While creating a LocalAsValue value, a missing attribute value was detected. "+
					"A LocalAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalAsValue Attribute Type",
				"While creating a LocalAsValue value, an invalid attribute value was detected. "+
					"A LocalAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalAsValue Attribute Value",
				"While creating a LocalAsValue value, an extra attribute value was detected. "+
					"A LocalAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalAsValueUnknown(), diags
	}

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	prependGlobalAsAttribute, ok := attributes["prepend_global_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_global_as is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	prependGlobalAsVal, ok := prependGlobalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_global_as expected to be basetypes.BoolValue, was: %T`, prependGlobalAsAttribute))
	}

	prependLocalAsAttribute, ok := attributes["prepend_local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_local_as is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	prependLocalAsVal, ok := prependLocalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_local_as expected to be basetypes.BoolValue, was: %T`, prependLocalAsAttribute))
	}

	if diags.HasError() {
		return NewLocalAsValueUnknown(), diags
	}

	return LocalAsValue{
		AutonomousSystem: autonomousSystemVal,
		PrependGlobalAs:  prependGlobalAsVal,
		PrependLocalAs:   prependLocalAsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalAsValue {
	object, diags := NewLocalAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalAsValueMust(LocalAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalAsType) ValueType(ctx context.Context) attr.Value {
	return LocalAsValue{}
}

var _ basetypes.ObjectValuable = LocalAsValue{}

type LocalAsValue struct {
	AutonomousSystem basetypes.Int64Value `tfsdk:"autonomous_system"`
	PrependGlobalAs  basetypes.BoolValue  `tfsdk:"prepend_global_as"`
	PrependLocalAs   basetypes.BoolValue  `tfsdk:"prepend_local_as"`
	state            attr.ValueState
}

func (v LocalAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prepend_global_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prepend_local_as"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_system"] = val

		val, err = v.PrependGlobalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepend_global_as"] = val

		val, err = v.PrependLocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepend_local_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalAsValue) String() string {
	return "LocalAsValue"
}

func (v LocalAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"prepend_global_as": basetypes.BoolType{},
		"prepend_local_as":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_system": v.AutonomousSystem,
			"prepend_global_as": v.PrependGlobalAs,
			"prepend_local_as":  v.PrependLocalAs,
		})

	return objVal, diags
}

func (v LocalAsValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousSystem.Equal(other.AutonomousSystem) {
		return false
	}

	if !v.PrependGlobalAs.Equal(other.PrependGlobalAs) {
		return false
	}

	if !v.PrependLocalAs.Equal(other.PrependLocalAs) {
		return false
	}

	return true
}

func (v LocalAsValue) Type(ctx context.Context) attr.Type {
	return LocalAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"prepend_global_as": basetypes.BoolType{},
		"prepend_local_as":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PeerAsType{}

type PeerAsType struct {
	basetypes.ObjectType
}

func (t PeerAsType) Equal(o attr.Type) bool {
	other, ok := o.(PeerAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PeerAsType) String() string {
	return "PeerAsType"
}

func (t PeerAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return nil, diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PeerAsValue{
		AutonomousSystem: autonomousSystemVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPeerAsValueNull() PeerAsValue {
	return PeerAsValue{
		state: attr.ValueStateNull,
	}
}

func NewPeerAsValueUnknown() PeerAsValue {
	return PeerAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPeerAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PeerAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PeerAsValue Attribute Value",
				"While creating a PeerAsValue value, a missing attribute value was detected. "+
					"A PeerAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PeerAsValue Attribute Type",
				"While creating a PeerAsValue value, an invalid attribute value was detected. "+
					"A PeerAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PeerAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PeerAsValue Attribute Value",
				"While creating a PeerAsValue value, an extra attribute value was detected. "+
					"A PeerAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PeerAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPeerAsValueUnknown(), diags
	}

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return NewPeerAsValueUnknown(), diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	if diags.HasError() {
		return NewPeerAsValueUnknown(), diags
	}

	return PeerAsValue{
		AutonomousSystem: autonomousSystemVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPeerAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PeerAsValue {
	object, diags := NewPeerAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPeerAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PeerAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPeerAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPeerAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPeerAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPeerAsValueMust(PeerAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PeerAsType) ValueType(ctx context.Context) attr.Value {
	return PeerAsValue{}
}

var _ basetypes.ObjectValuable = PeerAsValue{}

type PeerAsValue struct {
	AutonomousSystem basetypes.Int64Value `tfsdk:"autonomous_system"`
	state            attr.ValueState
}

func (v PeerAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.AutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_system"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PeerAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PeerAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PeerAsValue) String() string {
	return "PeerAsValue"
}

func (v PeerAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_system": v.AutonomousSystem,
		})

	return objVal, diags
}

func (v PeerAsValue) Equal(o attr.Value) bool {
	other, ok := o.(PeerAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousSystem.Equal(other.AutonomousSystem) {
		return false
	}

	return true
}

func (v PeerAsValue) Type(ctx context.Context) attr.Type {
	return PeerAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PeerAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SendDefaultRouteType{}

type SendDefaultRouteType struct {
	basetypes.ObjectType
}

func (t SendDefaultRouteType) Equal(o attr.Type) bool {
	other, ok := o.(SendDefaultRouteType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SendDefaultRouteType) String() string {
	return "SendDefaultRouteType"
}

func (t SendDefaultRouteType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return nil, diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.ListValue, was: %T`, addressFamilyAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SendDefaultRouteValue{
		AddressFamily: addressFamilyVal,
		ExportPolicy:  exportPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSendDefaultRouteValueNull() SendDefaultRouteValue {
	return SendDefaultRouteValue{
		state: attr.ValueStateNull,
	}
}

func NewSendDefaultRouteValueUnknown() SendDefaultRouteValue {
	return SendDefaultRouteValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSendDefaultRouteValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SendDefaultRouteValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SendDefaultRouteValue Attribute Value",
				"While creating a SendDefaultRouteValue value, a missing attribute value was detected. "+
					"A SendDefaultRouteValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SendDefaultRouteValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SendDefaultRouteValue Attribute Type",
				"While creating a SendDefaultRouteValue value, an invalid attribute value was detected. "+
					"A SendDefaultRouteValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SendDefaultRouteValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SendDefaultRouteValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SendDefaultRouteValue Attribute Value",
				"While creating a SendDefaultRouteValue value, an extra attribute value was detected. "+
					"A SendDefaultRouteValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SendDefaultRouteValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSendDefaultRouteValueUnknown(), diags
	}

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return NewSendDefaultRouteValueUnknown(), diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.ListValue, was: %T`, addressFamilyAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewSendDefaultRouteValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	if diags.HasError() {
		return NewSendDefaultRouteValueUnknown(), diags
	}

	return SendDefaultRouteValue{
		AddressFamily: addressFamilyVal,
		ExportPolicy:  exportPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSendDefaultRouteValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SendDefaultRouteValue {
	object, diags := NewSendDefaultRouteValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSendDefaultRouteValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SendDefaultRouteType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSendDefaultRouteValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSendDefaultRouteValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSendDefaultRouteValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSendDefaultRouteValueMust(SendDefaultRouteValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SendDefaultRouteType) ValueType(ctx context.Context) attr.Value {
	return SendDefaultRouteValue{}
}

var _ basetypes.ObjectValuable = SendDefaultRouteValue{}

type SendDefaultRouteValue struct {
	AddressFamily basetypes.ListValue   `tfsdk:"address_family"`
	ExportPolicy  basetypes.StringValue `tfsdk:"export_policy"`
	state         attr.ValueState
}

func (v SendDefaultRouteValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["address_family"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AddressFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_family"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SendDefaultRouteValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SendDefaultRouteValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SendDefaultRouteValue) String() string {
	return "SendDefaultRouteValue"
}

func (v SendDefaultRouteValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var addressFamilyVal basetypes.ListValue
	switch {
	case v.AddressFamily.IsUnknown():
		addressFamilyVal = types.ListUnknown(types.StringType)
	case v.AddressFamily.IsNull():
		addressFamilyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addressFamilyVal, d = types.ListValue(types.StringType, v.AddressFamily.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_family": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_policy": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address_family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_family": addressFamilyVal,
			"export_policy":  v.ExportPolicy,
		})

	return objVal, diags
}

func (v SendDefaultRouteValue) Equal(o attr.Value) bool {
	other, ok := o.(SendDefaultRouteValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressFamily.Equal(other.AddressFamily) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	return true
}

func (v SendDefaultRouteValue) Type(ctx context.Context) attr.Type {
	return SendDefaultRouteType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SendDefaultRouteValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TimersType{}

type TimersType struct {
	basetypes.ObjectType
}

func (t TimersType) Equal(o attr.Type) bool {
	other, ok := o.(TimersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TimersType) String() string {
	return "TimersType"
}

func (t TimersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return nil, diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return nil, diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return nil, diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TimersValue{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimersValueNull() TimersValue {
	return TimersValue{
		state: attr.ValueStateNull,
	}
}

func NewTimersValueUnknown() TimersValue {
	return TimersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTimersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TimersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TimersValue Attribute Value",
				"While creating a TimersValue value, a missing attribute value was detected. "+
					"A TimersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TimersValue Attribute Type",
				"While creating a TimersValue value, an invalid attribute value was detected. "+
					"A TimersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TimersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TimersValue Attribute Value",
				"While creating a TimersValue value, an extra attribute value was detected. "+
					"A TimersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TimersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimersValueUnknown(), diags
	}

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return NewTimersValueUnknown(), diags
	}

	return TimersValue{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TimersValue {
	object, diags := NewTimersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TimersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimersValueMust(TimersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TimersType) ValueType(ctx context.Context) attr.Value {
	return TimersValue{}
}

var _ basetypes.ObjectValuable = TimersValue{}

type TimersValue struct {
	ConnectRetry                 basetypes.Int64Value `tfsdk:"connect_retry"`
	HoldTime                     basetypes.Int64Value `tfsdk:"hold_time"`
	KeepAlive                    basetypes.Int64Value `tfsdk:"keep_alive"`
	MinimumAdvertisementInterval basetypes.Int64Value `tfsdk:"minimum_advertisement_interval"`
	state                        attr.ValueState
}

func (v TimersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["connect_retry"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_alive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minimum_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ConnectRetry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connect_retry"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.KeepAlive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_alive"] = val

		val, err = v.MinimumAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimum_advertisement_interval"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TimersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TimersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TimersValue) String() string {
	return "TimersValue"
}

func (v TimersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connect_retry":                  v.ConnectRetry,
			"hold_time":                      v.HoldTime,
			"keep_alive":                     v.KeepAlive,
			"minimum_advertisement_interval": v.MinimumAdvertisementInterval,
		})

	return objVal, diags
}

func (v TimersValue) Equal(o attr.Value) bool {
	other, ok := o.(TimersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConnectRetry.Equal(other.ConnectRetry) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.KeepAlive.Equal(other.KeepAlive) {
		return false
	}

	if !v.MinimumAdvertisementInterval.Equal(other.MinimumAdvertisementInterval) {
		return false
	}

	return true
}

func (v TimersValue) Type(ctx context.Context) attr.Type {
	return TimersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TimersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	numRouteReflectorBgppeersAttribute, ok := attributes["num_route_reflector_bgppeers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_route_reflector_bgppeers is missing from object`)

		return nil, diags
	}

	numRouteReflectorBgppeersVal, ok := numRouteReflectorBgppeersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_route_reflector_bgppeers expected to be basetypes.Int64Value, was: %T`, numRouteReflectorBgppeersAttribute))
	}

	numRouteReflectorBgppeersOperDownAttribute, ok := attributes["num_route_reflector_bgppeers_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_route_reflector_bgppeers_oper_down is missing from object`)

		return nil, diags
	}

	numRouteReflectorBgppeersOperDownVal, ok := numRouteReflectorBgppeersOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_route_reflector_bgppeers_oper_down expected to be basetypes.Int64Value, was: %T`, numRouteReflectorBgppeersOperDownAttribute))
	}

	operDownRouteReflectorPeersAttribute, ok := attributes["oper_down_route_reflector_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oper_down_route_reflector_peers is missing from object`)

		return nil, diags
	}

	operDownRouteReflectorPeersVal, ok := operDownRouteReflectorPeersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oper_down_route_reflector_peers expected to be basetypes.ListValue, was: %T`, operDownRouteReflectorPeersAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Health:                            healthVal,
		HealthScoreReason:                 healthScoreReasonVal,
		LastChange:                        lastChangeVal,
		NumRouteReflectorBgppeers:         numRouteReflectorBgppeersVal,
		NumRouteReflectorBgppeersOperDown: numRouteReflectorBgppeersOperDownVal,
		OperDownRouteReflectorPeers:       operDownRouteReflectorPeersVal,
		OperationalState:                  operationalStateVal,
		state:                             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	numRouteReflectorBgppeersAttribute, ok := attributes["num_route_reflector_bgppeers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_route_reflector_bgppeers is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numRouteReflectorBgppeersVal, ok := numRouteReflectorBgppeersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_route_reflector_bgppeers expected to be basetypes.Int64Value, was: %T`, numRouteReflectorBgppeersAttribute))
	}

	numRouteReflectorBgppeersOperDownAttribute, ok := attributes["num_route_reflector_bgppeers_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_route_reflector_bgppeers_oper_down is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numRouteReflectorBgppeersOperDownVal, ok := numRouteReflectorBgppeersOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_route_reflector_bgppeers_oper_down expected to be basetypes.Int64Value, was: %T`, numRouteReflectorBgppeersOperDownAttribute))
	}

	operDownRouteReflectorPeersAttribute, ok := attributes["oper_down_route_reflector_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oper_down_route_reflector_peers is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operDownRouteReflectorPeersVal, ok := operDownRouteReflectorPeersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oper_down_route_reflector_peers expected to be basetypes.ListValue, was: %T`, operDownRouteReflectorPeersAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Health:                            healthVal,
		HealthScoreReason:                 healthScoreReasonVal,
		LastChange:                        lastChangeVal,
		NumRouteReflectorBgppeers:         numRouteReflectorBgppeersVal,
		NumRouteReflectorBgppeersOperDown: numRouteReflectorBgppeersOperDownVal,
		OperDownRouteReflectorPeers:       operDownRouteReflectorPeersVal,
		OperationalState:                  operationalStateVal,
		state:                             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Health                            basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason                 basetypes.StringValue `tfsdk:"health_score_reason"`
	LastChange                        basetypes.StringValue `tfsdk:"last_change"`
	NumRouteReflectorBgppeers         basetypes.Int64Value  `tfsdk:"num_route_reflector_bgppeers"`
	NumRouteReflectorBgppeersOperDown basetypes.Int64Value  `tfsdk:"num_route_reflector_bgppeers_oper_down"`
	OperDownRouteReflectorPeers       basetypes.ListValue   `tfsdk:"oper_down_route_reflector_peers"`
	OperationalState                  basetypes.StringValue `tfsdk:"operational_state"`
	state                             attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["num_route_reflector_bgppeers"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_route_reflector_bgppeers_oper_down"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["oper_down_route_reflector_peers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.NumRouteReflectorBgppeers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_route_reflector_bgppeers"] = val

		val, err = v.NumRouteReflectorBgppeersOperDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_route_reflector_bgppeers_oper_down"] = val

		val, err = v.OperDownRouteReflectorPeers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oper_down_route_reflector_peers"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var operDownRouteReflectorPeersVal basetypes.ListValue
	switch {
	case v.OperDownRouteReflectorPeers.IsUnknown():
		operDownRouteReflectorPeersVal = types.ListUnknown(types.StringType)
	case v.OperDownRouteReflectorPeers.IsNull():
		operDownRouteReflectorPeersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		operDownRouteReflectorPeersVal, d = types.ListValue(types.StringType, v.OperDownRouteReflectorPeers.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"health":                                 basetypes.Int64Type{},
			"health_score_reason":                    basetypes.StringType{},
			"last_change":                            basetypes.StringType{},
			"num_route_reflector_bgppeers":           basetypes.Int64Type{},
			"num_route_reflector_bgppeers_oper_down": basetypes.Int64Type{},
			"oper_down_route_reflector_peers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"operational_state": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"health":                                 basetypes.Int64Type{},
		"health_score_reason":                    basetypes.StringType{},
		"last_change":                            basetypes.StringType{},
		"num_route_reflector_bgppeers":           basetypes.Int64Type{},
		"num_route_reflector_bgppeers_oper_down": basetypes.Int64Type{},
		"oper_down_route_reflector_peers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"operational_state": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"health":                                 v.Health,
			"health_score_reason":                    v.HealthScoreReason,
			"last_change":                            v.LastChange,
			"num_route_reflector_bgppeers":           v.NumRouteReflectorBgppeers,
			"num_route_reflector_bgppeers_oper_down": v.NumRouteReflectorBgppeersOperDown,
			"oper_down_route_reflector_peers":        operDownRouteReflectorPeersVal,
			"operational_state":                      v.OperationalState,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.NumRouteReflectorBgppeers.Equal(other.NumRouteReflectorBgppeers) {
		return false
	}

	if !v.NumRouteReflectorBgppeersOperDown.Equal(other.NumRouteReflectorBgppeersOperDown) {
		return false
	}

	if !v.OperDownRouteReflectorPeers.Equal(other.OperDownRouteReflectorPeers) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"health":                                 basetypes.Int64Type{},
		"health_score_reason":                    basetypes.StringType{},
		"last_change":                            basetypes.StringType{},
		"num_route_reflector_bgppeers":           basetypes.Int64Type{},
		"num_route_reflector_bgppeers_oper_down": basetypes.Int64Type{},
		"oper_down_route_reflector_peers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"operational_state": basetypes.StringType{},
	}
}
