// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_default_bgp_peer

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func DefaultBgpPeerDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"alarms": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"critical": schema.Int64Attribute{
						Computed: true,
					},
					"major": schema.Int64Attribute{
						Computed: true,
					},
					"minor": schema.Int64Attribute{
						Computed: true,
					},
					"warning": schema.Int64Attribute{
						Computed: true,
					},
				},
				CustomType: AlarmsType{
					ObjectType: types.ObjectType{
						AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"deviations": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"count": schema.Int64Attribute{
						Computed: true,
					},
				},
				CustomType: DeviationsType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"hash": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "resource content will be returned as it was at the time of this git hash",
				MarkdownDescription: "resource content will be returned as it was at the time of this git hash",
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"namespace": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "name of the DefaultBGPPeer",
				MarkdownDescription: "name of the DefaultBGPPeer",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"as_path_options": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_own_as": schema.Int64Attribute{
								Optional:            true,
								Description:         "The maximum number of times the global AS number or a local AS number of the BGP instance can appear in any received AS_PATH before it is considered a loop and considered invalid.",
								MarkdownDescription: "The maximum number of times the global AS number or a local AS number of the BGP instance can appear in any received AS_PATH before it is considered a loop and considered invalid.",
							},
							"remove_private_as": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"ignore_peer_as": schema.BoolAttribute{
										Optional:            true,
										Description:         "If set to true then do not delete or replace a private AS number that is the same as the peer AS number.",
										MarkdownDescription: "If set to true then do not delete or replace a private AS number that is the same as the peer AS number.",
									},
									"leading_only": schema.BoolAttribute{
										Optional:            true,
										Description:         "If set to true then only delete or replace private AS numbers that appear before the first occurrence of a non-private ASN in the sequence of most recent ASNs in the AS path.",
										MarkdownDescription: "If set to true then only delete or replace private AS numbers that appear before the first occurrence of a non-private ASN in the sequence of most recent ASNs in the AS path.",
									},
									"remove_private_as_mode": schema.StringAttribute{
										Optional:            true,
										Description:         "The method by which private AS numbers are removed from the advertised AS_PATH attribute.",
										MarkdownDescription: "The method by which private AS numbers are removed from the advertised AS_PATH attribute.",
									},
								},
								CustomType: RemovePrivateAsType{
									ObjectType: types.ObjectType{
										AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Options for removing private AS numbers (2-byte and 4-byte) from the advertised AS path towards all peers.",
								MarkdownDescription: "Options for removing private AS numbers (2-byte and 4-byte) from the advertised AS path towards all peers.",
							},
						},
						CustomType: AsPathOptionsType{
							ObjectType: types.ObjectType{
								AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "AS Path Options",
						MarkdownDescription: "AS Path Options",
					},
					"bfd": schema.BoolAttribute{
						Optional:            true,
						Description:         "Enable or disable Bi-forward Forwarding Detection (BFD) with fast failover.",
						MarkdownDescription: "Enable or disable Bi-forward Forwarding Detection (BFD) with fast failover.",
					},
					"client": schema.BoolAttribute{
						Optional:            true,
						Description:         "When set to true, all configured and dynamic BGP peers are considered RR clients.",
						MarkdownDescription: "When set to true, all configured and dynamic BGP peers are considered RR clients.",
					},
					"cluster_id": schema.StringAttribute{
						Optional:            true,
						Description:         "Enables route reflect client and sets the cluster ID.",
						MarkdownDescription: "Enables route reflect client and sets the cluster ID.",
					},
					"description": schema.StringAttribute{
						Optional:            true,
						Description:         "Sets the description on the BGP peer.",
						MarkdownDescription: "Sets the description on the BGP peer.",
					},
					"dynamic_neighbor": schema.BoolAttribute{
						Optional:            true,
						Description:         "When set to true the DefaultInterface is added to the dynamic-neighbor list for dynamic peering.",
						MarkdownDescription: "When set to true the DefaultInterface is added to the dynamic-neighbor list for dynamic peering.",
					},
					"dynamic_neighbor_allowed_peer_as": schema.ListAttribute{
						ElementType:         types.Int64Type,
						Optional:            true,
						Description:         "The autonomous system numbers allowed from peers if dynamic peering is enabled.",
						MarkdownDescription: "The autonomous system numbers allowed from peers if dynamic peering is enabled.",
					},
					"export_policy": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Reference to a Policy CR that will be used to filter routes advertised to peers.",
						MarkdownDescription: "Reference to a Policy CR that will be used to filter routes advertised to peers.",
					},
					"gr_stale_route_time": schema.Int64Attribute{
						Optional:            true,
						Description:         "Enables Graceful Restart on the peer and sets the stale route time.",
						MarkdownDescription: "Enables Graceful Restart on the peer and sets the stale route time.",
					},
					"group": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a DefaultBGPGroup.",
						MarkdownDescription: "Reference to a DefaultBGPGroup.",
					},
					"import_policy": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Reference to a Policy CR that will be used to filter routes received from peers.",
						MarkdownDescription: "Reference to a Policy CR that will be used to filter routes received from peers.",
					},
					"interface": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to either a DefaultInterface or SystemInterface whose IP will be used as a source IP for the BGP session.",
						MarkdownDescription: "Reference to either a DefaultInterface or SystemInterface whose IP will be used as a source IP for the BGP session.",
					},
					"interface_kind": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a the Kind of interface whose IP will be used as a source IP for the BGP session.",
						MarkdownDescription: "Reference to a the Kind of interface whose IP will be used as a source IP for the BGP session.",
					},
					"ipv4_unicast": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"advertise_ipv6_next_hops": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
								MarkdownDescription: "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables the IPv4 unicast AFISAFI.",
								MarkdownDescription: "Enables the IPv4 unicast AFISAFI.",
							},
							"prefix_limit": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"prefix_limit_accepted": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
											},
										},
										CustomType: PrefixLimitAcceptedType{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"prefix_limit_received": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
											},
										},
										CustomType: PrefixLimitReceivedType{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: PrefixLimitType{
									ObjectType: types.ObjectType{
										AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
							"receive_ipv6_next_hops": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
								MarkdownDescription: "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
							},
						},
						CustomType: Ipv4UnicastType{
							ObjectType: types.ObjectType{
								AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Parameters relating to the IPv4 unicast AFI/SAFI.",
						MarkdownDescription: "Parameters relating to the IPv4 unicast AFI/SAFI.",
					},
					"ipv6_unicast": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables the IPv6 unicast AFISAFI",
								MarkdownDescription: "Enables the IPv6 unicast AFISAFI",
							},
							"prefix_limit": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"prefix_limit_accepted": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
											},
										},
										CustomType: PrefixLimitAccepted1Type{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"prefix_limit_received": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
											},
										},
										CustomType: PrefixLimitReceived1Type{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: PrefixLimit1Type{
									ObjectType: types.ObjectType{
										AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
						},
						CustomType: Ipv6UnicastType{
							ObjectType: types.ObjectType{
								AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Parameters relating to the IPv6 unicast AFI/SAFI.",
						MarkdownDescription: "Parameters relating to the IPv6 unicast AFI/SAFI.",
					},
					"keychain": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a Keychain resource that will be used for authentication with the BGP peer.",
						MarkdownDescription: "Reference to a Keychain resource that will be used for authentication with the BGP peer.",
					},
					"l2_vpn_evpn": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"advertise_ipv6_next_hops": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables advertisement of EVPN routes with IPv6 next-hops to peers.",
								MarkdownDescription: "Enables advertisement of EVPN routes with IPv6 next-hops to peers.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables the L2VPN EVPN AFISAFI.",
								MarkdownDescription: "Enables the L2VPN EVPN AFISAFI.",
							},
							"prefix_limit": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"prefix_limit_accepted": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
											},
										},
										CustomType: PrefixLimitAccepted2Type{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"prefix_limit_received": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"log_only": schema.BoolAttribute{
												Optional:            true,
												Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
												MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
											},
											"max_received_routes": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
												MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
											},
											"warning_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
												MarkdownDescription: "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
											},
										},
										CustomType: PrefixLimitReceived2Type{
											ObjectType: types.ObjectType{
												AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: PrefixLimit2Type{
									ObjectType: types.ObjectType{
										AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
						},
						CustomType: L2VpnEvpnType{
							ObjectType: types.ObjectType{
								AttrTypes: L2VpnEvpnValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Parameters relating to the EVPN AFI/SAFI.",
						MarkdownDescription: "Parameters relating to the EVPN AFI/SAFI.",
					},
					"local_as": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"autonomous_system": schema.Int64Attribute{
								Optional:            true,
								Description:         "Local Autonomous System number.",
								MarkdownDescription: "Local Autonomous System number.",
							},
							"prepend_global_as": schema.BoolAttribute{
								Optional:            true,
								Description:         "When set to true, the global ASN value is prepended to the AS path in outbound routes towards each BGP peer.",
								MarkdownDescription: "When set to true, the global ASN value is prepended to the AS path in outbound routes towards each BGP peer.",
							},
							"prepend_local_as": schema.BoolAttribute{
								Optional:            true,
								Description:         "When set to true, the local AS value is prepended to the AS path of inbound routes from each EBGP peer.",
								MarkdownDescription: "When set to true, the local AS value is prepended to the AS path of inbound routes from each EBGP peer.",
							},
						},
						CustomType: LocalAsType{
							ObjectType: types.ObjectType{
								AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "The local autonomous system number advertised to peers.",
						MarkdownDescription: "The local autonomous system number advertised to peers.",
					},
					"local_preference": schema.Int64Attribute{
						Optional:            true,
						Description:         "Local Preference attribute added to received routes from the BGP peers, also sets local preference for generated routes.",
						MarkdownDescription: "Local Preference attribute added to received routes from the BGP peers, also sets local preference for generated routes.",
					},
					"multi_hop_max_hop": schema.Int64Attribute{
						Optional:            true,
						Description:         "Enable multihop for eBGP peers and sets the maximum number of hops allowed.",
						MarkdownDescription: "Enable multihop for eBGP peers and sets the maximum number of hops allowed.",
					},
					"next_hop_self": schema.BoolAttribute{
						Optional:            true,
						Description:         "When set to true, the next-hop in all IPv4-unicast, IPv6-unicast and EVPN BGP routes advertised to the peer is set to the local-address.",
						MarkdownDescription: "When set to true, the next-hop in all IPv4-unicast, IPv6-unicast and EVPN BGP routes advertised to the peer is set to the local-address.",
					},
					"peer_as": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"autonomous_system": schema.Int64Attribute{
								Optional:            true,
								Description:         "Local Autonomous System number.",
								MarkdownDescription: "Local Autonomous System number.",
							},
						},
						CustomType: PeerAsType{
							ObjectType: types.ObjectType{
								AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "The autonomous system number expected from peers.",
						MarkdownDescription: "The autonomous system number expected from peers.",
					},
					"peer_interface": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a DefaultInterface or SystemInterface resource to which the peering session will be established. There cannot be both a PeerIp and PeerDefaultInterface property set.",
						MarkdownDescription: "Reference to a DefaultInterface or SystemInterface resource to which the peering session will be established. There cannot be both a PeerIp and PeerDefaultInterface property set.",
					},
					"peer_interface_kind": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a the Kind of interface to which to peer to.",
						MarkdownDescription: "Reference to a the Kind of interface to which to peer to.",
					},
					"peer_ip": schema.StringAttribute{
						Optional:            true,
						Description:         "Peer IP to which the peering session will be established. There cannot be both a PeerIp and PeerDefaultInterface property set.",
						MarkdownDescription: "Peer IP to which the peering session will be established. There cannot be both a PeerIp and PeerDefaultInterface property set.",
					},
					"rtc": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"advertise_default_route": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables advertisement of a Default RTC Route to the BGP peers to receive all VPN routes.",
								MarkdownDescription: "Enables advertisement of a Default RTC Route to the BGP peers to receive all VPN routes.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables the Route Target Constraints SAFI.",
								MarkdownDescription: "Enables the Route Target Constraints SAFI.",
							},
						},
						CustomType: RtcType{
							ObjectType: types.ObjectType{
								AttrTypes: RtcValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Parameters relating to the RTC SAFI.",
						MarkdownDescription: "Parameters relating to the RTC SAFI.",
					},
					"send_community_large": schema.BoolAttribute{
						Optional:            true,
						Description:         "When false, all large (12 byte) BGP communities from all outbound routes advertised to the peer are stripped.",
						MarkdownDescription: "When false, all large (12 byte) BGP communities from all outbound routes advertised to the peer are stripped.",
					},
					"send_community_standard": schema.BoolAttribute{
						Optional:            true,
						Description:         "When false, all standard (4 byte) communities from all outbound routes advertised to the peer are stripped.",
						MarkdownDescription: "When false, all standard (4 byte) communities from all outbound routes advertised to the peer are stripped.",
					},
					"send_default_route": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"address_family": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Enables the sending of a synthetically generated default IPv4 or IPV6 route to each peer.",
								MarkdownDescription: "Enables the sending of a synthetically generated default IPv4 or IPV6 route to each peer.",
							},
							"export_policy": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to a Policy that should be applied to the advertised default routes, in order to set their attributes to non-default values.",
								MarkdownDescription: "Reference to a Policy that should be applied to the advertised default routes, in order to set their attributes to non-default values.",
							},
						},
						CustomType: SendDefaultRouteType{
							ObjectType: types.ObjectType{
								AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Options for controlling the generation of default routes towards BGP peers.",
						MarkdownDescription: "Options for controlling the generation of default routes towards BGP peers.",
					},
					"timers": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"connect_retry": schema.Int64Attribute{
								Optional:            true,
								Description:         "The time interval in seconds between successive attempts to establish a session with a peer.",
								MarkdownDescription: "The time interval in seconds between successive attempts to establish a session with a peer.",
							},
							"hold_time": schema.Int64Attribute{
								Optional:            true,
								Description:         "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
								MarkdownDescription: "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
							},
							"keep_alive": schema.Int64Attribute{
								Optional:            true,
								Description:         "The interval in seconds between successive keepalive messages sent to the peer.",
								MarkdownDescription: "The interval in seconds between successive keepalive messages sent to the peer.",
							},
							"minimum_advertisement_interval": schema.Int64Attribute{
								Optional:            true,
								Description:         "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
								MarkdownDescription: "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
							},
						},
						CustomType: TimersType{
							ObjectType: types.ObjectType{
								AttrTypes: TimersValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Timer configurations",
						MarkdownDescription: "Timer configurations",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "DefaultBGPPeer enables the configuration of BGP sessions within a DefaultRouter. It allows specifying a description, a DefaultInterface reference, and the peer IP address. The resource also supports dynamic neighbors, common BGP settings, and peer-specific configurations.",
				MarkdownDescription: "DefaultBGPPeer enables the configuration of BGP sessions within a DefaultRouter. It allows specifying a description, a DefaultInterface reference, and the peer IP address. The resource also supports dynamic neighbors, common BGP settings, and peer-specific configurations.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Computed:            true,
						Description:         "Indicated whether the BGP Peer is administratively enabled.",
						MarkdownDescription: "Indicated whether the BGP Peer is administratively enabled.",
					},
					"health": schema.Int64Attribute{
						Computed:            true,
						Description:         "Indicates the health score of the BGP peer.",
						MarkdownDescription: "Indicates the health score of the BGP peer.",
					},
					"health_score_reason": schema.StringAttribute{
						Computed:            true,
						Description:         "Indicates the reason for the health score.",
						MarkdownDescription: "Indicates the reason for the health score.",
					},
					"last_change": schema.StringAttribute{
						Computed:            true,
						Description:         "The time when the state of the resource last changed.",
						MarkdownDescription: "The time when the state of the resource last changed.",
					},
					"last_event": schema.StringAttribute{
						Computed:            true,
						Description:         "Last event of the BGP peer.",
						MarkdownDescription: "Last event of the BGP peer.",
					},
					"last_state": schema.StringAttribute{
						Computed:            true,
						Description:         "Last state of the BGP peer.",
						MarkdownDescription: "Last state of the BGP peer.",
					},
					"negotiated_hold_time": schema.Int64Attribute{
						Computed:            true,
						Description:         "Hold time negotiated with the BGP peer.",
						MarkdownDescription: "Hold time negotiated with the BGP peer.",
					},
					"negotiated_keepalive_interval": schema.Int64Attribute{
						Computed:            true,
						Description:         "Keepalive interval negotiated with the BGP peer.",
						MarkdownDescription: "Keepalive interval negotiated with the BGP peer.",
					},
					"operational_state": schema.StringAttribute{
						Computed:            true,
						Description:         "Operational state of the BGP peer",
						MarkdownDescription: "Operational state of the BGP peer",
					},
					"peer_as": schema.Int64Attribute{
						Computed:            true,
						Description:         "Peer AS of the BGP peer.",
						MarkdownDescription: "Peer AS of the BGP peer.",
					},
					"session_state": schema.StringAttribute{
						Computed:            true,
						Description:         "The state of the BGP session.",
						MarkdownDescription: "The state of the BGP session.",
					},
					"under_maintenance": schema.BoolAttribute{
						Computed:            true,
						Description:         "Indicates if the BGP peer is under maintenance.",
						MarkdownDescription: "Indicates if the BGP peer is under maintenance.",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "DefaultBGPPeerStatus defines the observed state of DefaultBGPPeer",
				MarkdownDescription: "DefaultBGPPeerStatus defines the observed state of DefaultBGPPeer",
			},
		},
	}
}

type DefaultBgpPeerModel struct {
	Alarms     AlarmsValue     `tfsdk:"alarms"`
	ApiVersion types.String    `tfsdk:"api_version"`
	Deviations DeviationsValue `tfsdk:"deviations"`
	Hash       types.String    `tfsdk:"hash"`
	Kind       types.String    `tfsdk:"kind"`
	Metadata   MetadataValue   `tfsdk:"metadata"`
	Name       types.String    `tfsdk:"name"`
	Namespace  types.String    `tfsdk:"namespace"`
	Spec       SpecValue       `tfsdk:"spec"`
	Status     StatusValue     `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = AlarmsType{}

type AlarmsType struct {
	basetypes.ObjectType
}

func (t AlarmsType) Equal(o attr.Type) bool {
	other, ok := o.(AlarmsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AlarmsType) String() string {
	return "AlarmsType"
}

func (t AlarmsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return nil, diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return nil, diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return nil, diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueNull() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateNull,
	}
}

func NewAlarmsValueUnknown() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAlarmsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AlarmsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, a missing attribute value was detected. "+
					"A AlarmsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AlarmsValue Attribute Type",
				"While creating a AlarmsValue value, an invalid attribute value was detected. "+
					"A AlarmsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, an extra attribute value was detected. "+
					"A AlarmsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AlarmsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AlarmsValue {
	object, diags := NewAlarmsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAlarmsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AlarmsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAlarmsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAlarmsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAlarmsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAlarmsValueMust(AlarmsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AlarmsType) ValueType(ctx context.Context) attr.Value {
	return AlarmsValue{}
}

var _ basetypes.ObjectValuable = AlarmsValue{}

type AlarmsValue struct {
	Critical basetypes.Int64Value `tfsdk:"critical"`
	Major    basetypes.Int64Value `tfsdk:"major"`
	Minor    basetypes.Int64Value `tfsdk:"minor"`
	Warning  basetypes.Int64Value `tfsdk:"warning"`
	state    attr.ValueState
}

func (v AlarmsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["critical"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Major.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["major"] = val

		val, err = v.Minor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minor"] = val

		val, err = v.Warning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AlarmsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AlarmsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AlarmsValue) String() string {
	return "AlarmsValue"
}

func (v AlarmsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"critical": v.Critical,
			"major":    v.Major,
			"minor":    v.Minor,
			"warning":  v.Warning,
		})

	return objVal, diags
}

func (v AlarmsValue) Equal(o attr.Value) bool {
	other, ok := o.(AlarmsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Major.Equal(other.Major) {
		return false
	}

	if !v.Minor.Equal(other.Minor) {
		return false
	}

	if !v.Warning.Equal(other.Warning) {
		return false
	}

	return true
}

func (v AlarmsValue) Type(ctx context.Context) attr.Type {
	return AlarmsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AlarmsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DeviationsType{}

type DeviationsType struct {
	basetypes.ObjectType
}

func (t DeviationsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviationsType) String() string {
	return "DeviationsType"
}

func (t DeviationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueNull() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviationsValueUnknown() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, a missing attribute value was detected. "+
					"A DeviationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviationsValue Attribute Type",
				"While creating a DeviationsValue value, an invalid attribute value was detected. "+
					"A DeviationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, an extra attribute value was detected. "+
					"A DeviationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewDeviationsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviationsValue {
	object, diags := NewDeviationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviationsValueMust(DeviationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviationsType) ValueType(ctx context.Context) attr.Value {
	return DeviationsValue{}
}

var _ basetypes.ObjectValuable = DeviationsValue{}

type DeviationsValue struct {
	Count basetypes.Int64Value `tfsdk:"count"`
	state attr.ValueState
}

func (v DeviationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviationsValue) String() string {
	return "DeviationsValue"
}

func (v DeviationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
		})

	return objVal, diags
}

func (v DeviationsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	return true
}

func (v DeviationsValue) Type(ctx context.Context) attr.Type {
	return DeviationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathOptionsAttribute, ok := attributes["as_path_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_options is missing from object`)

		return nil, diags
	}

	asPathOptionsVal, ok := asPathOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_options expected to be basetypes.ObjectValue, was: %T`, asPathOptionsAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return nil, diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.BoolValue, was: %T`, bfdAttribute))
	}

	clientAttribute, ok := attributes["client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client is missing from object`)

		return nil, diags
	}

	clientVal, ok := clientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client expected to be basetypes.BoolValue, was: %T`, clientAttribute))
	}

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return nil, diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	dynamicNeighborAttribute, ok := attributes["dynamic_neighbor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_neighbor is missing from object`)

		return nil, diags
	}

	dynamicNeighborVal, ok := dynamicNeighborAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_neighbor expected to be basetypes.BoolValue, was: %T`, dynamicNeighborAttribute))
	}

	dynamicNeighborAllowedPeerAsAttribute, ok := attributes["dynamic_neighbor_allowed_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_neighbor_allowed_peer_as is missing from object`)

		return nil, diags
	}

	dynamicNeighborAllowedPeerAsVal, ok := dynamicNeighborAllowedPeerAsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_neighbor_allowed_peer_as expected to be basetypes.ListValue, was: %T`, dynamicNeighborAllowedPeerAsAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	grStaleRouteTimeAttribute, ok := attributes["gr_stale_route_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gr_stale_route_time is missing from object`)

		return nil, diags
	}

	grStaleRouteTimeVal, ok := grStaleRouteTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gr_stale_route_time expected to be basetypes.Int64Value, was: %T`, grStaleRouteTimeAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceKindAttribute, ok := attributes["interface_kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_kind is missing from object`)

		return nil, diags
	}

	interfaceKindVal, ok := interfaceKindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_kind expected to be basetypes.StringValue, was: %T`, interfaceKindAttribute))
	}

	ipv4UnicastAttribute, ok := attributes["ipv4_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_unicast is missing from object`)

		return nil, diags
	}

	ipv4UnicastVal, ok := ipv4UnicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_unicast expected to be basetypes.ObjectValue, was: %T`, ipv4UnicastAttribute))
	}

	ipv6UnicastAttribute, ok := attributes["ipv6_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_unicast is missing from object`)

		return nil, diags
	}

	ipv6UnicastVal, ok := ipv6UnicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_unicast expected to be basetypes.ObjectValue, was: %T`, ipv6UnicastAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return nil, diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	l2VpnEvpnAttribute, ok := attributes["l2_vpn_evpn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2_vpn_evpn is missing from object`)

		return nil, diags
	}

	l2VpnEvpnVal, ok := l2VpnEvpnAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2_vpn_evpn expected to be basetypes.ObjectValue, was: %T`, l2VpnEvpnAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return nil, diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.ObjectValue, was: %T`, localAsAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return nil, diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	multiHopMaxHopAttribute, ok := attributes["multi_hop_max_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multi_hop_max_hop is missing from object`)

		return nil, diags
	}

	multiHopMaxHopVal, ok := multiHopMaxHopAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multi_hop_max_hop expected to be basetypes.Int64Value, was: %T`, multiHopMaxHopAttribute))
	}

	nextHopSelfAttribute, ok := attributes["next_hop_self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop_self is missing from object`)

		return nil, diags
	}

	nextHopSelfVal, ok := nextHopSelfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop_self expected to be basetypes.BoolValue, was: %T`, nextHopSelfAttribute))
	}

	peerAsAttribute, ok := attributes["peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_as is missing from object`)

		return nil, diags
	}

	peerAsVal, ok := peerAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_as expected to be basetypes.ObjectValue, was: %T`, peerAsAttribute))
	}

	peerInterfaceAttribute, ok := attributes["peer_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_interface is missing from object`)

		return nil, diags
	}

	peerInterfaceVal, ok := peerInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_interface expected to be basetypes.StringValue, was: %T`, peerInterfaceAttribute))
	}

	peerInterfaceKindAttribute, ok := attributes["peer_interface_kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_interface_kind is missing from object`)

		return nil, diags
	}

	peerInterfaceKindVal, ok := peerInterfaceKindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_interface_kind expected to be basetypes.StringValue, was: %T`, peerInterfaceKindAttribute))
	}

	peerIpAttribute, ok := attributes["peer_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_ip is missing from object`)

		return nil, diags
	}

	peerIpVal, ok := peerIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_ip expected to be basetypes.StringValue, was: %T`, peerIpAttribute))
	}

	rtcAttribute, ok := attributes["rtc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rtc is missing from object`)

		return nil, diags
	}

	rtcVal, ok := rtcAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rtc expected to be basetypes.ObjectValue, was: %T`, rtcAttribute))
	}

	sendCommunityLargeAttribute, ok := attributes["send_community_large"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_large is missing from object`)

		return nil, diags
	}

	sendCommunityLargeVal, ok := sendCommunityLargeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_large expected to be basetypes.BoolValue, was: %T`, sendCommunityLargeAttribute))
	}

	sendCommunityStandardAttribute, ok := attributes["send_community_standard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_standard is missing from object`)

		return nil, diags
	}

	sendCommunityStandardVal, ok := sendCommunityStandardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_standard expected to be basetypes.BoolValue, was: %T`, sendCommunityStandardAttribute))
	}

	sendDefaultRouteAttribute, ok := attributes["send_default_route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_default_route is missing from object`)

		return nil, diags
	}

	sendDefaultRouteVal, ok := sendDefaultRouteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_default_route expected to be basetypes.ObjectValue, was: %T`, sendDefaultRouteAttribute))
	}

	timersAttribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers is missing from object`)

		return nil, diags
	}

	timersVal, ok := timersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers expected to be basetypes.ObjectValue, was: %T`, timersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		AsPathOptions:                asPathOptionsVal,
		Bfd:                          bfdVal,
		Client:                       clientVal,
		ClusterId:                    clusterIdVal,
		Description:                  descriptionVal,
		DynamicNeighbor:              dynamicNeighborVal,
		DynamicNeighborAllowedPeerAs: dynamicNeighborAllowedPeerAsVal,
		ExportPolicy:                 exportPolicyVal,
		GrStaleRouteTime:             grStaleRouteTimeVal,
		Group:                        groupVal,
		ImportPolicy:                 importPolicyVal,
		Interface:                    interfaceVal,
		InterfaceKind:                interfaceKindVal,
		Ipv4Unicast:                  ipv4UnicastVal,
		Ipv6Unicast:                  ipv6UnicastVal,
		Keychain:                     keychainVal,
		L2VpnEvpn:                    l2VpnEvpnVal,
		LocalAs:                      localAsVal,
		LocalPreference:              localPreferenceVal,
		MultiHopMaxHop:               multiHopMaxHopVal,
		NextHopSelf:                  nextHopSelfVal,
		PeerAs:                       peerAsVal,
		PeerInterface:                peerInterfaceVal,
		PeerInterfaceKind:            peerInterfaceKindVal,
		PeerIp:                       peerIpVal,
		Rtc:                          rtcVal,
		SendCommunityLarge:           sendCommunityLargeVal,
		SendCommunityStandard:        sendCommunityStandardVal,
		SendDefaultRoute:             sendDefaultRouteVal,
		Timers:                       timersVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	asPathOptionsAttribute, ok := attributes["as_path_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_options is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	asPathOptionsVal, ok := asPathOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_options expected to be basetypes.ObjectValue, was: %T`, asPathOptionsAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.BoolValue, was: %T`, bfdAttribute))
	}

	clientAttribute, ok := attributes["client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	clientVal, ok := clientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client expected to be basetypes.BoolValue, was: %T`, clientAttribute))
	}

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	dynamicNeighborAttribute, ok := attributes["dynamic_neighbor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_neighbor is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	dynamicNeighborVal, ok := dynamicNeighborAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_neighbor expected to be basetypes.BoolValue, was: %T`, dynamicNeighborAttribute))
	}

	dynamicNeighborAllowedPeerAsAttribute, ok := attributes["dynamic_neighbor_allowed_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_neighbor_allowed_peer_as is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	dynamicNeighborAllowedPeerAsVal, ok := dynamicNeighborAllowedPeerAsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_neighbor_allowed_peer_as expected to be basetypes.ListValue, was: %T`, dynamicNeighborAllowedPeerAsAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	grStaleRouteTimeAttribute, ok := attributes["gr_stale_route_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gr_stale_route_time is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	grStaleRouteTimeVal, ok := grStaleRouteTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gr_stale_route_time expected to be basetypes.Int64Value, was: %T`, grStaleRouteTimeAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceKindAttribute, ok := attributes["interface_kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_kind is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	interfaceKindVal, ok := interfaceKindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_kind expected to be basetypes.StringValue, was: %T`, interfaceKindAttribute))
	}

	ipv4UnicastAttribute, ok := attributes["ipv4_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_unicast is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipv4UnicastVal, ok := ipv4UnicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_unicast expected to be basetypes.ObjectValue, was: %T`, ipv4UnicastAttribute))
	}

	ipv6UnicastAttribute, ok := attributes["ipv6_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_unicast is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipv6UnicastVal, ok := ipv6UnicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_unicast expected to be basetypes.ObjectValue, was: %T`, ipv6UnicastAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	l2VpnEvpnAttribute, ok := attributes["l2_vpn_evpn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2_vpn_evpn is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	l2VpnEvpnVal, ok := l2VpnEvpnAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2_vpn_evpn expected to be basetypes.ObjectValue, was: %T`, l2VpnEvpnAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.ObjectValue, was: %T`, localAsAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	multiHopMaxHopAttribute, ok := attributes["multi_hop_max_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multi_hop_max_hop is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	multiHopMaxHopVal, ok := multiHopMaxHopAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multi_hop_max_hop expected to be basetypes.Int64Value, was: %T`, multiHopMaxHopAttribute))
	}

	nextHopSelfAttribute, ok := attributes["next_hop_self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop_self is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nextHopSelfVal, ok := nextHopSelfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop_self expected to be basetypes.BoolValue, was: %T`, nextHopSelfAttribute))
	}

	peerAsAttribute, ok := attributes["peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_as is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	peerAsVal, ok := peerAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_as expected to be basetypes.ObjectValue, was: %T`, peerAsAttribute))
	}

	peerInterfaceAttribute, ok := attributes["peer_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_interface is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	peerInterfaceVal, ok := peerInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_interface expected to be basetypes.StringValue, was: %T`, peerInterfaceAttribute))
	}

	peerInterfaceKindAttribute, ok := attributes["peer_interface_kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_interface_kind is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	peerInterfaceKindVal, ok := peerInterfaceKindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_interface_kind expected to be basetypes.StringValue, was: %T`, peerInterfaceKindAttribute))
	}

	peerIpAttribute, ok := attributes["peer_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_ip is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	peerIpVal, ok := peerIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_ip expected to be basetypes.StringValue, was: %T`, peerIpAttribute))
	}

	rtcAttribute, ok := attributes["rtc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rtc is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	rtcVal, ok := rtcAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rtc expected to be basetypes.ObjectValue, was: %T`, rtcAttribute))
	}

	sendCommunityLargeAttribute, ok := attributes["send_community_large"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_large is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	sendCommunityLargeVal, ok := sendCommunityLargeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_large expected to be basetypes.BoolValue, was: %T`, sendCommunityLargeAttribute))
	}

	sendCommunityStandardAttribute, ok := attributes["send_community_standard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_standard is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	sendCommunityStandardVal, ok := sendCommunityStandardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_standard expected to be basetypes.BoolValue, was: %T`, sendCommunityStandardAttribute))
	}

	sendDefaultRouteAttribute, ok := attributes["send_default_route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_default_route is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	sendDefaultRouteVal, ok := sendDefaultRouteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_default_route expected to be basetypes.ObjectValue, was: %T`, sendDefaultRouteAttribute))
	}

	timersAttribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	timersVal, ok := timersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers expected to be basetypes.ObjectValue, was: %T`, timersAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		AsPathOptions:                asPathOptionsVal,
		Bfd:                          bfdVal,
		Client:                       clientVal,
		ClusterId:                    clusterIdVal,
		Description:                  descriptionVal,
		DynamicNeighbor:              dynamicNeighborVal,
		DynamicNeighborAllowedPeerAs: dynamicNeighborAllowedPeerAsVal,
		ExportPolicy:                 exportPolicyVal,
		GrStaleRouteTime:             grStaleRouteTimeVal,
		Group:                        groupVal,
		ImportPolicy:                 importPolicyVal,
		Interface:                    interfaceVal,
		InterfaceKind:                interfaceKindVal,
		Ipv4Unicast:                  ipv4UnicastVal,
		Ipv6Unicast:                  ipv6UnicastVal,
		Keychain:                     keychainVal,
		L2VpnEvpn:                    l2VpnEvpnVal,
		LocalAs:                      localAsVal,
		LocalPreference:              localPreferenceVal,
		MultiHopMaxHop:               multiHopMaxHopVal,
		NextHopSelf:                  nextHopSelfVal,
		PeerAs:                       peerAsVal,
		PeerInterface:                peerInterfaceVal,
		PeerInterfaceKind:            peerInterfaceKindVal,
		PeerIp:                       peerIpVal,
		Rtc:                          rtcVal,
		SendCommunityLarge:           sendCommunityLargeVal,
		SendCommunityStandard:        sendCommunityStandardVal,
		SendDefaultRoute:             sendDefaultRouteVal,
		Timers:                       timersVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	AsPathOptions                basetypes.ObjectValue `tfsdk:"as_path_options"`
	Bfd                          basetypes.BoolValue   `tfsdk:"bfd"`
	Client                       basetypes.BoolValue   `tfsdk:"client"`
	ClusterId                    basetypes.StringValue `tfsdk:"cluster_id"`
	Description                  basetypes.StringValue `tfsdk:"description"`
	DynamicNeighbor              basetypes.BoolValue   `tfsdk:"dynamic_neighbor"`
	DynamicNeighborAllowedPeerAs basetypes.ListValue   `tfsdk:"dynamic_neighbor_allowed_peer_as"`
	ExportPolicy                 basetypes.ListValue   `tfsdk:"export_policy"`
	GrStaleRouteTime             basetypes.Int64Value  `tfsdk:"gr_stale_route_time"`
	Group                        basetypes.StringValue `tfsdk:"group"`
	ImportPolicy                 basetypes.ListValue   `tfsdk:"import_policy"`
	Interface                    basetypes.StringValue `tfsdk:"interface"`
	InterfaceKind                basetypes.StringValue `tfsdk:"interface_kind"`
	Ipv4Unicast                  basetypes.ObjectValue `tfsdk:"ipv4_unicast"`
	Ipv6Unicast                  basetypes.ObjectValue `tfsdk:"ipv6_unicast"`
	Keychain                     basetypes.StringValue `tfsdk:"keychain"`
	L2VpnEvpn                    basetypes.ObjectValue `tfsdk:"l2_vpn_evpn"`
	LocalAs                      basetypes.ObjectValue `tfsdk:"local_as"`
	LocalPreference              basetypes.Int64Value  `tfsdk:"local_preference"`
	MultiHopMaxHop               basetypes.Int64Value  `tfsdk:"multi_hop_max_hop"`
	NextHopSelf                  basetypes.BoolValue   `tfsdk:"next_hop_self"`
	PeerAs                       basetypes.ObjectValue `tfsdk:"peer_as"`
	PeerInterface                basetypes.StringValue `tfsdk:"peer_interface"`
	PeerInterfaceKind            basetypes.StringValue `tfsdk:"peer_interface_kind"`
	PeerIp                       basetypes.StringValue `tfsdk:"peer_ip"`
	Rtc                          basetypes.ObjectValue `tfsdk:"rtc"`
	SendCommunityLarge           basetypes.BoolValue   `tfsdk:"send_community_large"`
	SendCommunityStandard        basetypes.BoolValue   `tfsdk:"send_community_standard"`
	SendDefaultRoute             basetypes.ObjectValue `tfsdk:"send_default_route"`
	Timers                       basetypes.ObjectValue `tfsdk:"timers"`
	state                        attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 30)

	var val tftypes.Value
	var err error

	attrTypes["as_path_options"] = basetypes.ObjectType{
		AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["bfd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["client"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cluster_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dynamic_neighbor"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dynamic_neighbor_allowed_peer_as"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gr_stale_route_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv4_unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6_unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["keychain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l2_vpn_evpn"] = basetypes.ObjectType{
		AttrTypes: L2VpnEvpnValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_as"] = basetypes.ObjectType{
		AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["multi_hop_max_hop"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_hop_self"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["peer_as"] = basetypes.ObjectType{
		AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["peer_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["peer_interface_kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["peer_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rtc"] = basetypes.ObjectType{
		AttrTypes: RtcValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["send_community_large"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["send_community_standard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["send_default_route"] = basetypes.ObjectType{
		AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["timers"] = basetypes.ObjectType{
		AttrTypes: TimersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 30)

		val, err = v.AsPathOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_options"] = val

		val, err = v.Bfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.Client.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client"] = val

		val, err = v.ClusterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_id"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DynamicNeighbor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_neighbor"] = val

		val, err = v.DynamicNeighborAllowedPeerAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_neighbor_allowed_peer_as"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.GrStaleRouteTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gr_stale_route_time"] = val

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.InterfaceKind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_kind"] = val

		val, err = v.Ipv4Unicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_unicast"] = val

		val, err = v.Ipv6Unicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_unicast"] = val

		val, err = v.Keychain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keychain"] = val

		val, err = v.L2VpnEvpn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l2_vpn_evpn"] = val

		val, err = v.LocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_as"] = val

		val, err = v.LocalPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_preference"] = val

		val, err = v.MultiHopMaxHop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multi_hop_max_hop"] = val

		val, err = v.NextHopSelf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_hop_self"] = val

		val, err = v.PeerAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_as"] = val

		val, err = v.PeerInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_interface"] = val

		val, err = v.PeerInterfaceKind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_interface_kind"] = val

		val, err = v.PeerIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_ip"] = val

		val, err = v.Rtc.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rtc"] = val

		val, err = v.SendCommunityLarge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_community_large"] = val

		val, err = v.SendCommunityStandard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_community_standard"] = val

		val, err = v.SendDefaultRoute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_default_route"] = val

		val, err = v.Timers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var asPathOptions basetypes.ObjectValue

	if v.AsPathOptions.IsNull() {
		asPathOptions = types.ObjectNull(
			AsPathOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.AsPathOptions.IsUnknown() {
		asPathOptions = types.ObjectUnknown(
			AsPathOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AsPathOptions.IsNull() && !v.AsPathOptions.IsUnknown() {
		asPathOptions = types.ObjectValueMust(
			AsPathOptionsValue{}.AttributeTypes(ctx),
			v.AsPathOptions.Attributes(),
		)
	}

	var ipv4Unicast basetypes.ObjectValue

	if v.Ipv4Unicast.IsNull() {
		ipv4Unicast = types.ObjectNull(
			Ipv4UnicastValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4Unicast.IsUnknown() {
		ipv4Unicast = types.ObjectUnknown(
			Ipv4UnicastValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4Unicast.IsNull() && !v.Ipv4Unicast.IsUnknown() {
		ipv4Unicast = types.ObjectValueMust(
			Ipv4UnicastValue{}.AttributeTypes(ctx),
			v.Ipv4Unicast.Attributes(),
		)
	}

	var ipv6Unicast basetypes.ObjectValue

	if v.Ipv6Unicast.IsNull() {
		ipv6Unicast = types.ObjectNull(
			Ipv6UnicastValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6Unicast.IsUnknown() {
		ipv6Unicast = types.ObjectUnknown(
			Ipv6UnicastValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6Unicast.IsNull() && !v.Ipv6Unicast.IsUnknown() {
		ipv6Unicast = types.ObjectValueMust(
			Ipv6UnicastValue{}.AttributeTypes(ctx),
			v.Ipv6Unicast.Attributes(),
		)
	}

	var l2VpnEvpn basetypes.ObjectValue

	if v.L2VpnEvpn.IsNull() {
		l2VpnEvpn = types.ObjectNull(
			L2VpnEvpnValue{}.AttributeTypes(ctx),
		)
	}

	if v.L2VpnEvpn.IsUnknown() {
		l2VpnEvpn = types.ObjectUnknown(
			L2VpnEvpnValue{}.AttributeTypes(ctx),
		)
	}

	if !v.L2VpnEvpn.IsNull() && !v.L2VpnEvpn.IsUnknown() {
		l2VpnEvpn = types.ObjectValueMust(
			L2VpnEvpnValue{}.AttributeTypes(ctx),
			v.L2VpnEvpn.Attributes(),
		)
	}

	var localAs basetypes.ObjectValue

	if v.LocalAs.IsNull() {
		localAs = types.ObjectNull(
			LocalAsValue{}.AttributeTypes(ctx),
		)
	}

	if v.LocalAs.IsUnknown() {
		localAs = types.ObjectUnknown(
			LocalAsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LocalAs.IsNull() && !v.LocalAs.IsUnknown() {
		localAs = types.ObjectValueMust(
			LocalAsValue{}.AttributeTypes(ctx),
			v.LocalAs.Attributes(),
		)
	}

	var peerAs basetypes.ObjectValue

	if v.PeerAs.IsNull() {
		peerAs = types.ObjectNull(
			PeerAsValue{}.AttributeTypes(ctx),
		)
	}

	if v.PeerAs.IsUnknown() {
		peerAs = types.ObjectUnknown(
			PeerAsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PeerAs.IsNull() && !v.PeerAs.IsUnknown() {
		peerAs = types.ObjectValueMust(
			PeerAsValue{}.AttributeTypes(ctx),
			v.PeerAs.Attributes(),
		)
	}

	var rtc basetypes.ObjectValue

	if v.Rtc.IsNull() {
		rtc = types.ObjectNull(
			RtcValue{}.AttributeTypes(ctx),
		)
	}

	if v.Rtc.IsUnknown() {
		rtc = types.ObjectUnknown(
			RtcValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Rtc.IsNull() && !v.Rtc.IsUnknown() {
		rtc = types.ObjectValueMust(
			RtcValue{}.AttributeTypes(ctx),
			v.Rtc.Attributes(),
		)
	}

	var sendDefaultRoute basetypes.ObjectValue

	if v.SendDefaultRoute.IsNull() {
		sendDefaultRoute = types.ObjectNull(
			SendDefaultRouteValue{}.AttributeTypes(ctx),
		)
	}

	if v.SendDefaultRoute.IsUnknown() {
		sendDefaultRoute = types.ObjectUnknown(
			SendDefaultRouteValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SendDefaultRoute.IsNull() && !v.SendDefaultRoute.IsUnknown() {
		sendDefaultRoute = types.ObjectValueMust(
			SendDefaultRouteValue{}.AttributeTypes(ctx),
			v.SendDefaultRoute.Attributes(),
		)
	}

	var timers basetypes.ObjectValue

	if v.Timers.IsNull() {
		timers = types.ObjectNull(
			TimersValue{}.AttributeTypes(ctx),
		)
	}

	if v.Timers.IsUnknown() {
		timers = types.ObjectUnknown(
			TimersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Timers.IsNull() && !v.Timers.IsUnknown() {
		timers = types.ObjectValueMust(
			TimersValue{}.AttributeTypes(ctx),
			v.Timers.Attributes(),
		)
	}

	var dynamicNeighborAllowedPeerAsVal basetypes.ListValue
	switch {
	case v.DynamicNeighborAllowedPeerAs.IsUnknown():
		dynamicNeighborAllowedPeerAsVal = types.ListUnknown(types.Int64Type)
	case v.DynamicNeighborAllowedPeerAs.IsNull():
		dynamicNeighborAllowedPeerAsVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		dynamicNeighborAllowedPeerAsVal, d = types.ListValue(types.Int64Type, v.DynamicNeighborAllowedPeerAs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
			},
			"bfd":              basetypes.BoolType{},
			"client":           basetypes.BoolType{},
			"cluster_id":       basetypes.StringType{},
			"description":      basetypes.StringType{},
			"dynamic_neighbor": basetypes.BoolType{},
			"dynamic_neighbor_allowed_peer_as": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"group":               basetypes.StringType{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interface":      basetypes.StringType{},
			"interface_kind": basetypes.StringType{},
			"ipv4_unicast": basetypes.ObjectType{
				AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
			},
			"ipv6_unicast": basetypes.ObjectType{
				AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"l2_vpn_evpn": basetypes.ObjectType{
				AttrTypes: L2VpnEvpnValue{}.AttributeTypes(ctx),
			},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
			},
			"local_preference":  basetypes.Int64Type{},
			"multi_hop_max_hop": basetypes.Int64Type{},
			"next_hop_self":     basetypes.BoolType{},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
			},
			"peer_interface":      basetypes.StringType{},
			"peer_interface_kind": basetypes.StringType{},
			"peer_ip":             basetypes.StringType{},
			"rtc": basetypes.ObjectType{
				AttrTypes: RtcValue{}.AttributeTypes(ctx),
			},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var exportPolicyVal basetypes.ListValue
	switch {
	case v.ExportPolicy.IsUnknown():
		exportPolicyVal = types.ListUnknown(types.StringType)
	case v.ExportPolicy.IsNull():
		exportPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exportPolicyVal, d = types.ListValue(types.StringType, v.ExportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
			},
			"bfd":              basetypes.BoolType{},
			"client":           basetypes.BoolType{},
			"cluster_id":       basetypes.StringType{},
			"description":      basetypes.StringType{},
			"dynamic_neighbor": basetypes.BoolType{},
			"dynamic_neighbor_allowed_peer_as": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"group":               basetypes.StringType{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interface":      basetypes.StringType{},
			"interface_kind": basetypes.StringType{},
			"ipv4_unicast": basetypes.ObjectType{
				AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
			},
			"ipv6_unicast": basetypes.ObjectType{
				AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"l2_vpn_evpn": basetypes.ObjectType{
				AttrTypes: L2VpnEvpnValue{}.AttributeTypes(ctx),
			},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
			},
			"local_preference":  basetypes.Int64Type{},
			"multi_hop_max_hop": basetypes.Int64Type{},
			"next_hop_self":     basetypes.BoolType{},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
			},
			"peer_interface":      basetypes.StringType{},
			"peer_interface_kind": basetypes.StringType{},
			"peer_ip":             basetypes.StringType{},
			"rtc": basetypes.ObjectType{
				AttrTypes: RtcValue{}.AttributeTypes(ctx),
			},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var importPolicyVal basetypes.ListValue
	switch {
	case v.ImportPolicy.IsUnknown():
		importPolicyVal = types.ListUnknown(types.StringType)
	case v.ImportPolicy.IsNull():
		importPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		importPolicyVal, d = types.ListValue(types.StringType, v.ImportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
			},
			"bfd":              basetypes.BoolType{},
			"client":           basetypes.BoolType{},
			"cluster_id":       basetypes.StringType{},
			"description":      basetypes.StringType{},
			"dynamic_neighbor": basetypes.BoolType{},
			"dynamic_neighbor_allowed_peer_as": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"group":               basetypes.StringType{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interface":      basetypes.StringType{},
			"interface_kind": basetypes.StringType{},
			"ipv4_unicast": basetypes.ObjectType{
				AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
			},
			"ipv6_unicast": basetypes.ObjectType{
				AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"l2_vpn_evpn": basetypes.ObjectType{
				AttrTypes: L2VpnEvpnValue{}.AttributeTypes(ctx),
			},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
			},
			"local_preference":  basetypes.Int64Type{},
			"multi_hop_max_hop": basetypes.Int64Type{},
			"next_hop_self":     basetypes.BoolType{},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
			},
			"peer_interface":      basetypes.StringType{},
			"peer_interface_kind": basetypes.StringType{},
			"peer_ip":             basetypes.StringType{},
			"rtc": basetypes.ObjectType{
				AttrTypes: RtcValue{}.AttributeTypes(ctx),
			},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path_options": basetypes.ObjectType{
			AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
		},
		"bfd":              basetypes.BoolType{},
		"client":           basetypes.BoolType{},
		"cluster_id":       basetypes.StringType{},
		"description":      basetypes.StringType{},
		"dynamic_neighbor": basetypes.BoolType{},
		"dynamic_neighbor_allowed_peer_as": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gr_stale_route_time": basetypes.Int64Type{},
		"group":               basetypes.StringType{},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"interface":      basetypes.StringType{},
		"interface_kind": basetypes.StringType{},
		"ipv4_unicast": basetypes.ObjectType{
			AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
		},
		"ipv6_unicast": basetypes.ObjectType{
			AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
		},
		"keychain": basetypes.StringType{},
		"l2_vpn_evpn": basetypes.ObjectType{
			AttrTypes: L2VpnEvpnValue{}.AttributeTypes(ctx),
		},
		"local_as": basetypes.ObjectType{
			AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
		},
		"local_preference":  basetypes.Int64Type{},
		"multi_hop_max_hop": basetypes.Int64Type{},
		"next_hop_self":     basetypes.BoolType{},
		"peer_as": basetypes.ObjectType{
			AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
		},
		"peer_interface":      basetypes.StringType{},
		"peer_interface_kind": basetypes.StringType{},
		"peer_ip":             basetypes.StringType{},
		"rtc": basetypes.ObjectType{
			AttrTypes: RtcValue{}.AttributeTypes(ctx),
		},
		"send_community_large":    basetypes.BoolType{},
		"send_community_standard": basetypes.BoolType{},
		"send_default_route": basetypes.ObjectType{
			AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
		},
		"timers": basetypes.ObjectType{
			AttrTypes: TimersValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_options":                  asPathOptions,
			"bfd":                              v.Bfd,
			"client":                           v.Client,
			"cluster_id":                       v.ClusterId,
			"description":                      v.Description,
			"dynamic_neighbor":                 v.DynamicNeighbor,
			"dynamic_neighbor_allowed_peer_as": dynamicNeighborAllowedPeerAsVal,
			"export_policy":                    exportPolicyVal,
			"gr_stale_route_time":              v.GrStaleRouteTime,
			"group":                            v.Group,
			"import_policy":                    importPolicyVal,
			"interface":                        v.Interface,
			"interface_kind":                   v.InterfaceKind,
			"ipv4_unicast":                     ipv4Unicast,
			"ipv6_unicast":                     ipv6Unicast,
			"keychain":                         v.Keychain,
			"l2_vpn_evpn":                      l2VpnEvpn,
			"local_as":                         localAs,
			"local_preference":                 v.LocalPreference,
			"multi_hop_max_hop":                v.MultiHopMaxHop,
			"next_hop_self":                    v.NextHopSelf,
			"peer_as":                          peerAs,
			"peer_interface":                   v.PeerInterface,
			"peer_interface_kind":              v.PeerInterfaceKind,
			"peer_ip":                          v.PeerIp,
			"rtc":                              rtc,
			"send_community_large":             v.SendCommunityLarge,
			"send_community_standard":          v.SendCommunityStandard,
			"send_default_route":               sendDefaultRoute,
			"timers":                           timers,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathOptions.Equal(other.AsPathOptions) {
		return false
	}

	if !v.Bfd.Equal(other.Bfd) {
		return false
	}

	if !v.Client.Equal(other.Client) {
		return false
	}

	if !v.ClusterId.Equal(other.ClusterId) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DynamicNeighbor.Equal(other.DynamicNeighbor) {
		return false
	}

	if !v.DynamicNeighborAllowedPeerAs.Equal(other.DynamicNeighborAllowedPeerAs) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.GrStaleRouteTime.Equal(other.GrStaleRouteTime) {
		return false
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.InterfaceKind.Equal(other.InterfaceKind) {
		return false
	}

	if !v.Ipv4Unicast.Equal(other.Ipv4Unicast) {
		return false
	}

	if !v.Ipv6Unicast.Equal(other.Ipv6Unicast) {
		return false
	}

	if !v.Keychain.Equal(other.Keychain) {
		return false
	}

	if !v.L2VpnEvpn.Equal(other.L2VpnEvpn) {
		return false
	}

	if !v.LocalAs.Equal(other.LocalAs) {
		return false
	}

	if !v.LocalPreference.Equal(other.LocalPreference) {
		return false
	}

	if !v.MultiHopMaxHop.Equal(other.MultiHopMaxHop) {
		return false
	}

	if !v.NextHopSelf.Equal(other.NextHopSelf) {
		return false
	}

	if !v.PeerAs.Equal(other.PeerAs) {
		return false
	}

	if !v.PeerInterface.Equal(other.PeerInterface) {
		return false
	}

	if !v.PeerInterfaceKind.Equal(other.PeerInterfaceKind) {
		return false
	}

	if !v.PeerIp.Equal(other.PeerIp) {
		return false
	}

	if !v.Rtc.Equal(other.Rtc) {
		return false
	}

	if !v.SendCommunityLarge.Equal(other.SendCommunityLarge) {
		return false
	}

	if !v.SendCommunityStandard.Equal(other.SendCommunityStandard) {
		return false
	}

	if !v.SendDefaultRoute.Equal(other.SendDefaultRoute) {
		return false
	}

	if !v.Timers.Equal(other.Timers) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_options": basetypes.ObjectType{
			AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
		},
		"bfd":              basetypes.BoolType{},
		"client":           basetypes.BoolType{},
		"cluster_id":       basetypes.StringType{},
		"description":      basetypes.StringType{},
		"dynamic_neighbor": basetypes.BoolType{},
		"dynamic_neighbor_allowed_peer_as": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gr_stale_route_time": basetypes.Int64Type{},
		"group":               basetypes.StringType{},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"interface":      basetypes.StringType{},
		"interface_kind": basetypes.StringType{},
		"ipv4_unicast": basetypes.ObjectType{
			AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
		},
		"ipv6_unicast": basetypes.ObjectType{
			AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
		},
		"keychain": basetypes.StringType{},
		"l2_vpn_evpn": basetypes.ObjectType{
			AttrTypes: L2VpnEvpnValue{}.AttributeTypes(ctx),
		},
		"local_as": basetypes.ObjectType{
			AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
		},
		"local_preference":  basetypes.Int64Type{},
		"multi_hop_max_hop": basetypes.Int64Type{},
		"next_hop_self":     basetypes.BoolType{},
		"peer_as": basetypes.ObjectType{
			AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
		},
		"peer_interface":      basetypes.StringType{},
		"peer_interface_kind": basetypes.StringType{},
		"peer_ip":             basetypes.StringType{},
		"rtc": basetypes.ObjectType{
			AttrTypes: RtcValue{}.AttributeTypes(ctx),
		},
		"send_community_large":    basetypes.BoolType{},
		"send_community_standard": basetypes.BoolType{},
		"send_default_route": basetypes.ObjectType{
			AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
		},
		"timers": basetypes.ObjectType{
			AttrTypes: TimersValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AsPathOptionsType{}

type AsPathOptionsType struct {
	basetypes.ObjectType
}

func (t AsPathOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(AsPathOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AsPathOptionsType) String() string {
	return "AsPathOptionsType"
}

func (t AsPathOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowOwnAsAttribute, ok := attributes["allow_own_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_own_as is missing from object`)

		return nil, diags
	}

	allowOwnAsVal, ok := allowOwnAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_own_as expected to be basetypes.Int64Value, was: %T`, allowOwnAsAttribute))
	}

	removePrivateAsAttribute, ok := attributes["remove_private_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as is missing from object`)

		return nil, diags
	}

	removePrivateAsVal, ok := removePrivateAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as expected to be basetypes.ObjectValue, was: %T`, removePrivateAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AsPathOptionsValue{
		AllowOwnAs:      allowOwnAsVal,
		RemovePrivateAs: removePrivateAsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAsPathOptionsValueNull() AsPathOptionsValue {
	return AsPathOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewAsPathOptionsValueUnknown() AsPathOptionsValue {
	return AsPathOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAsPathOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AsPathOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AsPathOptionsValue Attribute Value",
				"While creating a AsPathOptionsValue value, a missing attribute value was detected. "+
					"A AsPathOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AsPathOptionsValue Attribute Type",
				"While creating a AsPathOptionsValue value, an invalid attribute value was detected. "+
					"A AsPathOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AsPathOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AsPathOptionsValue Attribute Value",
				"While creating a AsPathOptionsValue value, an extra attribute value was detected. "+
					"A AsPathOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AsPathOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAsPathOptionsValueUnknown(), diags
	}

	allowOwnAsAttribute, ok := attributes["allow_own_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_own_as is missing from object`)

		return NewAsPathOptionsValueUnknown(), diags
	}

	allowOwnAsVal, ok := allowOwnAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_own_as expected to be basetypes.Int64Value, was: %T`, allowOwnAsAttribute))
	}

	removePrivateAsAttribute, ok := attributes["remove_private_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as is missing from object`)

		return NewAsPathOptionsValueUnknown(), diags
	}

	removePrivateAsVal, ok := removePrivateAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as expected to be basetypes.ObjectValue, was: %T`, removePrivateAsAttribute))
	}

	if diags.HasError() {
		return NewAsPathOptionsValueUnknown(), diags
	}

	return AsPathOptionsValue{
		AllowOwnAs:      allowOwnAsVal,
		RemovePrivateAs: removePrivateAsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAsPathOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AsPathOptionsValue {
	object, diags := NewAsPathOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAsPathOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AsPathOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAsPathOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAsPathOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAsPathOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAsPathOptionsValueMust(AsPathOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AsPathOptionsType) ValueType(ctx context.Context) attr.Value {
	return AsPathOptionsValue{}
}

var _ basetypes.ObjectValuable = AsPathOptionsValue{}

type AsPathOptionsValue struct {
	AllowOwnAs      basetypes.Int64Value  `tfsdk:"allow_own_as"`
	RemovePrivateAs basetypes.ObjectValue `tfsdk:"remove_private_as"`
	state           attr.ValueState
}

func (v AsPathOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["allow_own_as"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remove_private_as"] = basetypes.ObjectType{
		AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AllowOwnAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_own_as"] = val

		val, err = v.RemovePrivateAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove_private_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AsPathOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AsPathOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AsPathOptionsValue) String() string {
	return "AsPathOptionsValue"
}

func (v AsPathOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var removePrivateAs basetypes.ObjectValue

	if v.RemovePrivateAs.IsNull() {
		removePrivateAs = types.ObjectNull(
			RemovePrivateAsValue{}.AttributeTypes(ctx),
		)
	}

	if v.RemovePrivateAs.IsUnknown() {
		removePrivateAs = types.ObjectUnknown(
			RemovePrivateAsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RemovePrivateAs.IsNull() && !v.RemovePrivateAs.IsUnknown() {
		removePrivateAs = types.ObjectValueMust(
			RemovePrivateAsValue{}.AttributeTypes(ctx),
			v.RemovePrivateAs.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"allow_own_as": basetypes.Int64Type{},
		"remove_private_as": basetypes.ObjectType{
			AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_own_as":      v.AllowOwnAs,
			"remove_private_as": removePrivateAs,
		})

	return objVal, diags
}

func (v AsPathOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(AsPathOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowOwnAs.Equal(other.AllowOwnAs) {
		return false
	}

	if !v.RemovePrivateAs.Equal(other.RemovePrivateAs) {
		return false
	}

	return true
}

func (v AsPathOptionsValue) Type(ctx context.Context) attr.Type {
	return AsPathOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AsPathOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_own_as": basetypes.Int64Type{},
		"remove_private_as": basetypes.ObjectType{
			AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = RemovePrivateAsType{}

type RemovePrivateAsType struct {
	basetypes.ObjectType
}

func (t RemovePrivateAsType) Equal(o attr.Type) bool {
	other, ok := o.(RemovePrivateAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemovePrivateAsType) String() string {
	return "RemovePrivateAsType"
}

func (t RemovePrivateAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ignorePeerAsAttribute, ok := attributes["ignore_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_peer_as is missing from object`)

		return nil, diags
	}

	ignorePeerAsVal, ok := ignorePeerAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_peer_as expected to be basetypes.BoolValue, was: %T`, ignorePeerAsAttribute))
	}

	leadingOnlyAttribute, ok := attributes["leading_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leading_only is missing from object`)

		return nil, diags
	}

	leadingOnlyVal, ok := leadingOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leading_only expected to be basetypes.BoolValue, was: %T`, leadingOnlyAttribute))
	}

	removePrivateAsModeAttribute, ok := attributes["remove_private_as_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as_mode is missing from object`)

		return nil, diags
	}

	removePrivateAsModeVal, ok := removePrivateAsModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as_mode expected to be basetypes.StringValue, was: %T`, removePrivateAsModeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemovePrivateAsValue{
		IgnorePeerAs:        ignorePeerAsVal,
		LeadingOnly:         leadingOnlyVal,
		RemovePrivateAsMode: removePrivateAsModeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRemovePrivateAsValueNull() RemovePrivateAsValue {
	return RemovePrivateAsValue{
		state: attr.ValueStateNull,
	}
}

func NewRemovePrivateAsValueUnknown() RemovePrivateAsValue {
	return RemovePrivateAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemovePrivateAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemovePrivateAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemovePrivateAsValue Attribute Value",
				"While creating a RemovePrivateAsValue value, a missing attribute value was detected. "+
					"A RemovePrivateAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemovePrivateAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemovePrivateAsValue Attribute Type",
				"While creating a RemovePrivateAsValue value, an invalid attribute value was detected. "+
					"A RemovePrivateAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemovePrivateAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemovePrivateAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemovePrivateAsValue Attribute Value",
				"While creating a RemovePrivateAsValue value, an extra attribute value was detected. "+
					"A RemovePrivateAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemovePrivateAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemovePrivateAsValueUnknown(), diags
	}

	ignorePeerAsAttribute, ok := attributes["ignore_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_peer_as is missing from object`)

		return NewRemovePrivateAsValueUnknown(), diags
	}

	ignorePeerAsVal, ok := ignorePeerAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_peer_as expected to be basetypes.BoolValue, was: %T`, ignorePeerAsAttribute))
	}

	leadingOnlyAttribute, ok := attributes["leading_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leading_only is missing from object`)

		return NewRemovePrivateAsValueUnknown(), diags
	}

	leadingOnlyVal, ok := leadingOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leading_only expected to be basetypes.BoolValue, was: %T`, leadingOnlyAttribute))
	}

	removePrivateAsModeAttribute, ok := attributes["remove_private_as_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as_mode is missing from object`)

		return NewRemovePrivateAsValueUnknown(), diags
	}

	removePrivateAsModeVal, ok := removePrivateAsModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as_mode expected to be basetypes.StringValue, was: %T`, removePrivateAsModeAttribute))
	}

	if diags.HasError() {
		return NewRemovePrivateAsValueUnknown(), diags
	}

	return RemovePrivateAsValue{
		IgnorePeerAs:        ignorePeerAsVal,
		LeadingOnly:         leadingOnlyVal,
		RemovePrivateAsMode: removePrivateAsModeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRemovePrivateAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemovePrivateAsValue {
	object, diags := NewRemovePrivateAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemovePrivateAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemovePrivateAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemovePrivateAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemovePrivateAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemovePrivateAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemovePrivateAsValueMust(RemovePrivateAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemovePrivateAsType) ValueType(ctx context.Context) attr.Value {
	return RemovePrivateAsValue{}
}

var _ basetypes.ObjectValuable = RemovePrivateAsValue{}

type RemovePrivateAsValue struct {
	IgnorePeerAs        basetypes.BoolValue   `tfsdk:"ignore_peer_as"`
	LeadingOnly         basetypes.BoolValue   `tfsdk:"leading_only"`
	RemovePrivateAsMode basetypes.StringValue `tfsdk:"remove_private_as_mode"`
	state               attr.ValueState
}

func (v RemovePrivateAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["ignore_peer_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["leading_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["remove_private_as_mode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.IgnorePeerAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ignore_peer_as"] = val

		val, err = v.LeadingOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["leading_only"] = val

		val, err = v.RemovePrivateAsMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove_private_as_mode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemovePrivateAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemovePrivateAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemovePrivateAsValue) String() string {
	return "RemovePrivateAsValue"
}

func (v RemovePrivateAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ignore_peer_as":         basetypes.BoolType{},
		"leading_only":           basetypes.BoolType{},
		"remove_private_as_mode": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ignore_peer_as":         v.IgnorePeerAs,
			"leading_only":           v.LeadingOnly,
			"remove_private_as_mode": v.RemovePrivateAsMode,
		})

	return objVal, diags
}

func (v RemovePrivateAsValue) Equal(o attr.Value) bool {
	other, ok := o.(RemovePrivateAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IgnorePeerAs.Equal(other.IgnorePeerAs) {
		return false
	}

	if !v.LeadingOnly.Equal(other.LeadingOnly) {
		return false
	}

	if !v.RemovePrivateAsMode.Equal(other.RemovePrivateAsMode) {
		return false
	}

	return true
}

func (v RemovePrivateAsValue) Type(ctx context.Context) attr.Type {
	return RemovePrivateAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemovePrivateAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ignore_peer_as":         basetypes.BoolType{},
		"leading_only":           basetypes.BoolType{},
		"remove_private_as_mode": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4UnicastType{}

type Ipv4UnicastType struct {
	basetypes.ObjectType
}

func (t Ipv4UnicastType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4UnicastType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4UnicastType) String() string {
	return "Ipv4UnicastType"
}

func (t Ipv4UnicastType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertiseIpv6NextHopsAttribute, ok := attributes["advertise_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6_next_hops is missing from object`)

		return nil, diags
	}

	advertiseIpv6NextHopsVal, ok := advertiseIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6NextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimitAttribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit is missing from object`)

		return nil, diags
	}

	prefixLimitVal, ok := prefixLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit expected to be basetypes.ObjectValue, was: %T`, prefixLimitAttribute))
	}

	receiveIpv6NextHopsAttribute, ok := attributes["receive_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6_next_hops is missing from object`)

		return nil, diags
	}

	receiveIpv6NextHopsVal, ok := receiveIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6NextHopsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4UnicastValue{
		AdvertiseIpv6NextHops: advertiseIpv6NextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit:           prefixLimitVal,
		ReceiveIpv6NextHops:   receiveIpv6NextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4UnicastValueNull() Ipv4UnicastValue {
	return Ipv4UnicastValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4UnicastValueUnknown() Ipv4UnicastValue {
	return Ipv4UnicastValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4UnicastValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4UnicastValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4UnicastValue Attribute Value",
				"While creating a Ipv4UnicastValue value, a missing attribute value was detected. "+
					"A Ipv4UnicastValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4UnicastValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4UnicastValue Attribute Type",
				"While creating a Ipv4UnicastValue value, an invalid attribute value was detected. "+
					"A Ipv4UnicastValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4UnicastValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4UnicastValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4UnicastValue Attribute Value",
				"While creating a Ipv4UnicastValue value, an extra attribute value was detected. "+
					"A Ipv4UnicastValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4UnicastValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4UnicastValueUnknown(), diags
	}

	advertiseIpv6NextHopsAttribute, ok := attributes["advertise_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6_next_hops is missing from object`)

		return NewIpv4UnicastValueUnknown(), diags
	}

	advertiseIpv6NextHopsVal, ok := advertiseIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6NextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv4UnicastValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimitAttribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit is missing from object`)

		return NewIpv4UnicastValueUnknown(), diags
	}

	prefixLimitVal, ok := prefixLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit expected to be basetypes.ObjectValue, was: %T`, prefixLimitAttribute))
	}

	receiveIpv6NextHopsAttribute, ok := attributes["receive_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6_next_hops is missing from object`)

		return NewIpv4UnicastValueUnknown(), diags
	}

	receiveIpv6NextHopsVal, ok := receiveIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6NextHopsAttribute))
	}

	if diags.HasError() {
		return NewIpv4UnicastValueUnknown(), diags
	}

	return Ipv4UnicastValue{
		AdvertiseIpv6NextHops: advertiseIpv6NextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit:           prefixLimitVal,
		ReceiveIpv6NextHops:   receiveIpv6NextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4UnicastValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4UnicastValue {
	object, diags := NewIpv4UnicastValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4UnicastValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4UnicastType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4UnicastValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4UnicastValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4UnicastValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4UnicastValueMust(Ipv4UnicastValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4UnicastType) ValueType(ctx context.Context) attr.Value {
	return Ipv4UnicastValue{}
}

var _ basetypes.ObjectValuable = Ipv4UnicastValue{}

type Ipv4UnicastValue struct {
	AdvertiseIpv6NextHops basetypes.BoolValue   `tfsdk:"advertise_ipv6_next_hops"`
	Enabled               basetypes.BoolValue   `tfsdk:"enabled"`
	PrefixLimit           basetypes.ObjectValue `tfsdk:"prefix_limit"`
	ReceiveIpv6NextHops   basetypes.BoolValue   `tfsdk:"receive_ipv6_next_hops"`
	state                 attr.ValueState
}

func (v Ipv4UnicastValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["advertise_ipv6_next_hops"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix_limit"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["receive_ipv6_next_hops"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdvertiseIpv6NextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertise_ipv6_next_hops"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.PrefixLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit"] = val

		val, err = v.ReceiveIpv6NextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["receive_ipv6_next_hops"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4UnicastValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4UnicastValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4UnicastValue) String() string {
	return "Ipv4UnicastValue"
}

func (v Ipv4UnicastValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimit basetypes.ObjectValue

	if v.PrefixLimit.IsNull() {
		prefixLimit = types.ObjectNull(
			PrefixLimitValue{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimit.IsUnknown() {
		prefixLimit = types.ObjectUnknown(
			PrefixLimitValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimit.IsNull() && !v.PrefixLimit.IsUnknown() {
		prefixLimit = types.ObjectValueMust(
			PrefixLimitValue{}.AttributeTypes(ctx),
			v.PrefixLimit.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"advertise_ipv6_next_hops": basetypes.BoolType{},
		"enabled":                  basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
		},
		"receive_ipv6_next_hops": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertise_ipv6_next_hops": v.AdvertiseIpv6NextHops,
			"enabled":                  v.Enabled,
			"prefix_limit":             prefixLimit,
			"receive_ipv6_next_hops":   v.ReceiveIpv6NextHops,
		})

	return objVal, diags
}

func (v Ipv4UnicastValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4UnicastValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertiseIpv6NextHops.Equal(other.AdvertiseIpv6NextHops) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.PrefixLimit.Equal(other.PrefixLimit) {
		return false
	}

	if !v.ReceiveIpv6NextHops.Equal(other.ReceiveIpv6NextHops) {
		return false
	}

	return true
}

func (v Ipv4UnicastValue) Type(ctx context.Context) attr.Type {
	return Ipv4UnicastType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4UnicastValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertise_ipv6_next_hops": basetypes.BoolType{},
		"enabled":                  basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
		},
		"receive_ipv6_next_hops": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitType{}

type PrefixLimitType struct {
	basetypes.ObjectType
}

func (t PrefixLimitType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitType) String() string {
	return "PrefixLimitType"
}

func (t PrefixLimitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixLimitAcceptedAttribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted is missing from object`)

		return nil, diags
	}

	prefixLimitAcceptedVal, ok := prefixLimitAcceptedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted expected to be basetypes.ObjectValue, was: %T`, prefixLimitAcceptedAttribute))
	}

	prefixLimitReceivedAttribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received is missing from object`)

		return nil, diags
	}

	prefixLimitReceivedVal, ok := prefixLimitReceivedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceivedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitValue{
		PrefixLimitAccepted: prefixLimitAcceptedVal,
		PrefixLimitReceived: prefixLimitReceivedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitValueNull() PrefixLimitValue {
	return PrefixLimitValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitValueUnknown() PrefixLimitValue {
	return PrefixLimitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitValue Attribute Value",
				"While creating a PrefixLimitValue value, a missing attribute value was detected. "+
					"A PrefixLimitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitValue Attribute Type",
				"While creating a PrefixLimitValue value, an invalid attribute value was detected. "+
					"A PrefixLimitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitValue Attribute Value",
				"While creating a PrefixLimitValue value, an extra attribute value was detected. "+
					"A PrefixLimitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitValueUnknown(), diags
	}

	prefixLimitAcceptedAttribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted is missing from object`)

		return NewPrefixLimitValueUnknown(), diags
	}

	prefixLimitAcceptedVal, ok := prefixLimitAcceptedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted expected to be basetypes.ObjectValue, was: %T`, prefixLimitAcceptedAttribute))
	}

	prefixLimitReceivedAttribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received is missing from object`)

		return NewPrefixLimitValueUnknown(), diags
	}

	prefixLimitReceivedVal, ok := prefixLimitReceivedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceivedAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitValueUnknown(), diags
	}

	return PrefixLimitValue{
		PrefixLimitAccepted: prefixLimitAcceptedVal,
		PrefixLimitReceived: prefixLimitReceivedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitValue {
	object, diags := NewPrefixLimitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitValueMust(PrefixLimitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitType) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitValue{}
}

var _ basetypes.ObjectValuable = PrefixLimitValue{}

type PrefixLimitValue struct {
	PrefixLimitAccepted basetypes.ObjectValue `tfsdk:"prefix_limit_accepted"`
	PrefixLimitReceived basetypes.ObjectValue `tfsdk:"prefix_limit_received"`
	state               attr.ValueState
}

func (v PrefixLimitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["prefix_limit_accepted"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_limit_received"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PrefixLimitAccepted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_accepted"] = val

		val, err = v.PrefixLimitReceived.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_received"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitValue) String() string {
	return "PrefixLimitValue"
}

func (v PrefixLimitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimitAccepted basetypes.ObjectValue

	if v.PrefixLimitAccepted.IsNull() {
		prefixLimitAccepted = types.ObjectNull(
			PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitAccepted.IsUnknown() {
		prefixLimitAccepted = types.ObjectUnknown(
			PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitAccepted.IsNull() && !v.PrefixLimitAccepted.IsUnknown() {
		prefixLimitAccepted = types.ObjectValueMust(
			PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
			v.PrefixLimitAccepted.Attributes(),
		)
	}

	var prefixLimitReceived basetypes.ObjectValue

	if v.PrefixLimitReceived.IsNull() {
		prefixLimitReceived = types.ObjectNull(
			PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitReceived.IsUnknown() {
		prefixLimitReceived = types.ObjectUnknown(
			PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitReceived.IsNull() && !v.PrefixLimitReceived.IsUnknown() {
		prefixLimitReceived = types.ObjectValueMust(
			PrefixLimitReceivedValue{}.AttributeTypes(ctx),
			v.PrefixLimitReceived.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix_limit_accepted": prefixLimitAccepted,
			"prefix_limit_received": prefixLimitReceived,
		})

	return objVal, diags
}

func (v PrefixLimitValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PrefixLimitAccepted.Equal(other.PrefixLimitAccepted) {
		return false
	}

	if !v.PrefixLimitReceived.Equal(other.PrefixLimitReceived) {
		return false
	}

	return true
}

func (v PrefixLimitValue) Type(ctx context.Context) attr.Type {
	return PrefixLimitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitAcceptedType{}

type PrefixLimitAcceptedType struct {
	basetypes.ObjectType
}

func (t PrefixLimitAcceptedType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitAcceptedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitAcceptedType) String() string {
	return "PrefixLimitAcceptedType"
}

func (t PrefixLimitAcceptedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitAcceptedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAcceptedValueNull() PrefixLimitAcceptedValue {
	return PrefixLimitAcceptedValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitAcceptedValueUnknown() PrefixLimitAcceptedValue {
	return PrefixLimitAcceptedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitAcceptedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitAcceptedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitAcceptedValue Attribute Value",
				"While creating a PrefixLimitAcceptedValue value, a missing attribute value was detected. "+
					"A PrefixLimitAcceptedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAcceptedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitAcceptedValue Attribute Type",
				"While creating a PrefixLimitAcceptedValue value, an invalid attribute value was detected. "+
					"A PrefixLimitAcceptedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAcceptedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitAcceptedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitAcceptedValue Attribute Value",
				"While creating a PrefixLimitAcceptedValue value, an extra attribute value was detected. "+
					"A PrefixLimitAcceptedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitAcceptedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	return PrefixLimitAcceptedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAcceptedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitAcceptedValue {
	object, diags := NewPrefixLimitAcceptedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitAcceptedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitAcceptedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitAcceptedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitAcceptedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitAcceptedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitAcceptedValueMust(PrefixLimitAcceptedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitAcceptedType) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitAcceptedValue{}
}

var _ basetypes.ObjectValuable = PrefixLimitAcceptedValue{}

type PrefixLimitAcceptedValue struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitAcceptedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitAcceptedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitAcceptedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitAcceptedValue) String() string {
	return "PrefixLimitAcceptedValue"
}

func (v PrefixLimitAcceptedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitAcceptedValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitAcceptedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitAcceptedValue) Type(ctx context.Context) attr.Type {
	return PrefixLimitAcceptedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitAcceptedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitReceivedType{}

type PrefixLimitReceivedType struct {
	basetypes.ObjectType
}

func (t PrefixLimitReceivedType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitReceivedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitReceivedType) String() string {
	return "PrefixLimitReceivedType"
}

func (t PrefixLimitReceivedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitReceivedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceivedValueNull() PrefixLimitReceivedValue {
	return PrefixLimitReceivedValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitReceivedValueUnknown() PrefixLimitReceivedValue {
	return PrefixLimitReceivedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitReceivedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitReceivedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitReceivedValue Attribute Value",
				"While creating a PrefixLimitReceivedValue value, a missing attribute value was detected. "+
					"A PrefixLimitReceivedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceivedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitReceivedValue Attribute Type",
				"While creating a PrefixLimitReceivedValue value, an invalid attribute value was detected. "+
					"A PrefixLimitReceivedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceivedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitReceivedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitReceivedValue Attribute Value",
				"While creating a PrefixLimitReceivedValue value, an extra attribute value was detected. "+
					"A PrefixLimitReceivedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitReceivedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	return PrefixLimitReceivedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceivedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitReceivedValue {
	object, diags := NewPrefixLimitReceivedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitReceivedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitReceivedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitReceivedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitReceivedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitReceivedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitReceivedValueMust(PrefixLimitReceivedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitReceivedType) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitReceivedValue{}
}

var _ basetypes.ObjectValuable = PrefixLimitReceivedValue{}

type PrefixLimitReceivedValue struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitReceivedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitReceivedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitReceivedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitReceivedValue) String() string {
	return "PrefixLimitReceivedValue"
}

func (v PrefixLimitReceivedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitReceivedValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitReceivedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitReceivedValue) Type(ctx context.Context) attr.Type {
	return PrefixLimitReceivedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitReceivedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Ipv6UnicastType{}

type Ipv6UnicastType struct {
	basetypes.ObjectType
}

func (t Ipv6UnicastType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6UnicastType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6UnicastType) String() string {
	return "Ipv6UnicastType"
}

func (t Ipv6UnicastType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit1Attribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_1 is missing from object`)

		return nil, diags
	}

	prefixLimit1Val, ok := prefixLimit1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimit1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6UnicastValue{
		Enabled:      enabledVal,
		PrefixLimit1: prefixLimit1Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpv6UnicastValueNull() Ipv6UnicastValue {
	return Ipv6UnicastValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6UnicastValueUnknown() Ipv6UnicastValue {
	return Ipv6UnicastValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6UnicastValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6UnicastValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6UnicastValue Attribute Value",
				"While creating a Ipv6UnicastValue value, a missing attribute value was detected. "+
					"A Ipv6UnicastValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6UnicastValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6UnicastValue Attribute Type",
				"While creating a Ipv6UnicastValue value, an invalid attribute value was detected. "+
					"A Ipv6UnicastValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6UnicastValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6UnicastValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6UnicastValue Attribute Value",
				"While creating a Ipv6UnicastValue value, an extra attribute value was detected. "+
					"A Ipv6UnicastValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6UnicastValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6UnicastValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv6UnicastValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit1Attribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_1 is missing from object`)

		return NewIpv6UnicastValueUnknown(), diags
	}

	prefixLimit1Val, ok := prefixLimit1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimit1Attribute))
	}

	if diags.HasError() {
		return NewIpv6UnicastValueUnknown(), diags
	}

	return Ipv6UnicastValue{
		Enabled:      enabledVal,
		PrefixLimit1: prefixLimit1Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpv6UnicastValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6UnicastValue {
	object, diags := NewIpv6UnicastValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6UnicastValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6UnicastType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6UnicastValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6UnicastValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6UnicastValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6UnicastValueMust(Ipv6UnicastValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6UnicastType) ValueType(ctx context.Context) attr.Value {
	return Ipv6UnicastValue{}
}

var _ basetypes.ObjectValuable = Ipv6UnicastValue{}

type Ipv6UnicastValue struct {
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	PrefixLimit1 basetypes.ObjectValue `tfsdk:"prefix_limit"`
	state        attr.ValueState
}

func (v Ipv6UnicastValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix_limit"] = basetypes.ObjectType{
		AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.PrefixLimit1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6UnicastValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6UnicastValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6UnicastValue) String() string {
	return "Ipv6UnicastValue"
}

func (v Ipv6UnicastValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimit1 basetypes.ObjectValue

	if v.PrefixLimit1.IsNull() {
		prefixLimit1 = types.ObjectNull(
			PrefixLimit1Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimit1.IsUnknown() {
		prefixLimit1 = types.ObjectUnknown(
			PrefixLimit1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimit1.IsNull() && !v.PrefixLimit1.IsUnknown() {
		prefixLimit1 = types.ObjectValueMust(
			PrefixLimit1Value{}.AttributeTypes(ctx),
			v.PrefixLimit1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":      v.Enabled,
			"prefix_limit": prefixLimit1,
		})

	return objVal, diags
}

func (v Ipv6UnicastValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6UnicastValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.PrefixLimit1.Equal(other.PrefixLimit1) {
		return false
	}

	return true
}

func (v Ipv6UnicastValue) Type(ctx context.Context) attr.Type {
	return Ipv6UnicastType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6UnicastValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimit1Type{}

type PrefixLimit1Type struct {
	basetypes.ObjectType
}

func (t PrefixLimit1Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimit1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimit1Type) String() string {
	return "PrefixLimit1Type"
}

func (t PrefixLimit1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixLimitAccepted1Attribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_1 is missing from object`)

		return nil, diags
	}

	prefixLimitAccepted1Val, ok := prefixLimitAccepted1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted1Attribute))
	}

	prefixLimitReceived1Attribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_1 is missing from object`)

		return nil, diags
	}

	prefixLimitReceived1Val, ok := prefixLimitReceived1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimit1Value{
		PrefixLimitAccepted1: prefixLimitAccepted1Val,
		PrefixLimitReceived1: prefixLimitReceived1Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit1ValueNull() PrefixLimit1Value {
	return PrefixLimit1Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimit1ValueUnknown() PrefixLimit1Value {
	return PrefixLimit1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimit1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimit1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimit1Value Attribute Value",
				"While creating a PrefixLimit1Value value, a missing attribute value was detected. "+
					"A PrefixLimit1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimit1Value Attribute Type",
				"While creating a PrefixLimit1Value value, an invalid attribute value was detected. "+
					"A PrefixLimit1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimit1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimit1Value Attribute Value",
				"While creating a PrefixLimit1Value value, an extra attribute value was detected. "+
					"A PrefixLimit1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimit1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimit1ValueUnknown(), diags
	}

	prefixLimitAccepted1Attribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_1 is missing from object`)

		return NewPrefixLimit1ValueUnknown(), diags
	}

	prefixLimitAccepted1Val, ok := prefixLimitAccepted1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted1Attribute))
	}

	prefixLimitReceived1Attribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_1 is missing from object`)

		return NewPrefixLimit1ValueUnknown(), diags
	}

	prefixLimitReceived1Val, ok := prefixLimitReceived1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived1Attribute))
	}

	if diags.HasError() {
		return NewPrefixLimit1ValueUnknown(), diags
	}

	return PrefixLimit1Value{
		PrefixLimitAccepted1: prefixLimitAccepted1Val,
		PrefixLimitReceived1: prefixLimitReceived1Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimit1Value {
	object, diags := NewPrefixLimit1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimit1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimit1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimit1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimit1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimit1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimit1ValueMust(PrefixLimit1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimit1Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimit1Value{}
}

var _ basetypes.ObjectValuable = PrefixLimit1Value{}

type PrefixLimit1Value struct {
	PrefixLimitAccepted1 basetypes.ObjectValue `tfsdk:"prefix_limit_accepted"`
	PrefixLimitReceived1 basetypes.ObjectValue `tfsdk:"prefix_limit_received"`
	state                attr.ValueState
}

func (v PrefixLimit1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["prefix_limit_accepted"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_limit_received"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PrefixLimitAccepted1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_accepted"] = val

		val, err = v.PrefixLimitReceived1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_received"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimit1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimit1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimit1Value) String() string {
	return "PrefixLimit1Value"
}

func (v PrefixLimit1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimitAccepted1 basetypes.ObjectValue

	if v.PrefixLimitAccepted1.IsNull() {
		prefixLimitAccepted1 = types.ObjectNull(
			PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitAccepted1.IsUnknown() {
		prefixLimitAccepted1 = types.ObjectUnknown(
			PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitAccepted1.IsNull() && !v.PrefixLimitAccepted1.IsUnknown() {
		prefixLimitAccepted1 = types.ObjectValueMust(
			PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
			v.PrefixLimitAccepted1.Attributes(),
		)
	}

	var prefixLimitReceived1 basetypes.ObjectValue

	if v.PrefixLimitReceived1.IsNull() {
		prefixLimitReceived1 = types.ObjectNull(
			PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitReceived1.IsUnknown() {
		prefixLimitReceived1 = types.ObjectUnknown(
			PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitReceived1.IsNull() && !v.PrefixLimitReceived1.IsUnknown() {
		prefixLimitReceived1 = types.ObjectValueMust(
			PrefixLimitReceived1Value{}.AttributeTypes(ctx),
			v.PrefixLimitReceived1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix_limit_accepted": prefixLimitAccepted1,
			"prefix_limit_received": prefixLimitReceived1,
		})

	return objVal, diags
}

func (v PrefixLimit1Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimit1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PrefixLimitAccepted1.Equal(other.PrefixLimitAccepted1) {
		return false
	}

	if !v.PrefixLimitReceived1.Equal(other.PrefixLimitReceived1) {
		return false
	}

	return true
}

func (v PrefixLimit1Value) Type(ctx context.Context) attr.Type {
	return PrefixLimit1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimit1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitAccepted1Type{}

type PrefixLimitAccepted1Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitAccepted1Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitAccepted1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitAccepted1Type) String() string {
	return "PrefixLimitAccepted1Type"
}

func (t PrefixLimitAccepted1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitAccepted1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted1ValueNull() PrefixLimitAccepted1Value {
	return PrefixLimitAccepted1Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitAccepted1ValueUnknown() PrefixLimitAccepted1Value {
	return PrefixLimitAccepted1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitAccepted1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitAccepted1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitAccepted1Value Attribute Value",
				"While creating a PrefixLimitAccepted1Value value, a missing attribute value was detected. "+
					"A PrefixLimitAccepted1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitAccepted1Value Attribute Type",
				"While creating a PrefixLimitAccepted1Value value, an invalid attribute value was detected. "+
					"A PrefixLimitAccepted1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitAccepted1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitAccepted1Value Attribute Value",
				"While creating a PrefixLimitAccepted1Value value, an extra attribute value was detected. "+
					"A PrefixLimitAccepted1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitAccepted1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	return PrefixLimitAccepted1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitAccepted1Value {
	object, diags := NewPrefixLimitAccepted1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitAccepted1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitAccepted1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitAccepted1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitAccepted1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitAccepted1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitAccepted1ValueMust(PrefixLimitAccepted1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitAccepted1Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitAccepted1Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitAccepted1Value{}

type PrefixLimitAccepted1Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitAccepted1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitAccepted1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitAccepted1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitAccepted1Value) String() string {
	return "PrefixLimitAccepted1Value"
}

func (v PrefixLimitAccepted1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitAccepted1Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitAccepted1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitAccepted1Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitAccepted1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitAccepted1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitReceived1Type{}

type PrefixLimitReceived1Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitReceived1Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitReceived1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitReceived1Type) String() string {
	return "PrefixLimitReceived1Type"
}

func (t PrefixLimitReceived1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitReceived1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived1ValueNull() PrefixLimitReceived1Value {
	return PrefixLimitReceived1Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitReceived1ValueUnknown() PrefixLimitReceived1Value {
	return PrefixLimitReceived1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitReceived1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitReceived1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitReceived1Value Attribute Value",
				"While creating a PrefixLimitReceived1Value value, a missing attribute value was detected. "+
					"A PrefixLimitReceived1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitReceived1Value Attribute Type",
				"While creating a PrefixLimitReceived1Value value, an invalid attribute value was detected. "+
					"A PrefixLimitReceived1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitReceived1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitReceived1Value Attribute Value",
				"While creating a PrefixLimitReceived1Value value, an extra attribute value was detected. "+
					"A PrefixLimitReceived1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitReceived1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	return PrefixLimitReceived1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitReceived1Value {
	object, diags := NewPrefixLimitReceived1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitReceived1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitReceived1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitReceived1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitReceived1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitReceived1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitReceived1ValueMust(PrefixLimitReceived1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitReceived1Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitReceived1Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitReceived1Value{}

type PrefixLimitReceived1Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitReceived1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitReceived1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitReceived1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitReceived1Value) String() string {
	return "PrefixLimitReceived1Value"
}

func (v PrefixLimitReceived1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitReceived1Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitReceived1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitReceived1Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitReceived1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitReceived1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = L2VpnEvpnType{}

type L2VpnEvpnType struct {
	basetypes.ObjectType
}

func (t L2VpnEvpnType) Equal(o attr.Type) bool {
	other, ok := o.(L2VpnEvpnType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L2VpnEvpnType) String() string {
	return "L2VpnEvpnType"
}

func (t L2VpnEvpnType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertiseIpv6NextHopsAttribute, ok := attributes["advertise_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6_next_hops is missing from object`)

		return nil, diags
	}

	advertiseIpv6NextHopsVal, ok := advertiseIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6NextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit2Attribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_2 is missing from object`)

		return nil, diags
	}

	prefixLimit2Val, ok := prefixLimit2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimit2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L2VpnEvpnValue{
		AdvertiseIpv6NextHops: advertiseIpv6NextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit2:          prefixLimit2Val,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewL2VpnEvpnValueNull() L2VpnEvpnValue {
	return L2VpnEvpnValue{
		state: attr.ValueStateNull,
	}
}

func NewL2VpnEvpnValueUnknown() L2VpnEvpnValue {
	return L2VpnEvpnValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL2VpnEvpnValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L2VpnEvpnValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L2VpnEvpnValue Attribute Value",
				"While creating a L2VpnEvpnValue value, a missing attribute value was detected. "+
					"A L2VpnEvpnValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L2VpnEvpnValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L2VpnEvpnValue Attribute Type",
				"While creating a L2VpnEvpnValue value, an invalid attribute value was detected. "+
					"A L2VpnEvpnValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L2VpnEvpnValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L2VpnEvpnValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L2VpnEvpnValue Attribute Value",
				"While creating a L2VpnEvpnValue value, an extra attribute value was detected. "+
					"A L2VpnEvpnValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L2VpnEvpnValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL2VpnEvpnValueUnknown(), diags
	}

	advertiseIpv6NextHopsAttribute, ok := attributes["advertise_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6_next_hops is missing from object`)

		return NewL2VpnEvpnValueUnknown(), diags
	}

	advertiseIpv6NextHopsVal, ok := advertiseIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6NextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewL2VpnEvpnValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit2Attribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_2 is missing from object`)

		return NewL2VpnEvpnValueUnknown(), diags
	}

	prefixLimit2Val, ok := prefixLimit2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimit2Attribute))
	}

	if diags.HasError() {
		return NewL2VpnEvpnValueUnknown(), diags
	}

	return L2VpnEvpnValue{
		AdvertiseIpv6NextHops: advertiseIpv6NextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit2:          prefixLimit2Val,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewL2VpnEvpnValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L2VpnEvpnValue {
	object, diags := NewL2VpnEvpnValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL2VpnEvpnValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L2VpnEvpnType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL2VpnEvpnValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL2VpnEvpnValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL2VpnEvpnValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL2VpnEvpnValueMust(L2VpnEvpnValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L2VpnEvpnType) ValueType(ctx context.Context) attr.Value {
	return L2VpnEvpnValue{}
}

var _ basetypes.ObjectValuable = L2VpnEvpnValue{}

type L2VpnEvpnValue struct {
	AdvertiseIpv6NextHops basetypes.BoolValue   `tfsdk:"advertise_ipv6_next_hops"`
	Enabled               basetypes.BoolValue   `tfsdk:"enabled"`
	PrefixLimit2          basetypes.ObjectValue `tfsdk:"prefix_limit"`
	state                 attr.ValueState
}

func (v L2VpnEvpnValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["advertise_ipv6_next_hops"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix_limit"] = basetypes.ObjectType{
		AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AdvertiseIpv6NextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertise_ipv6_next_hops"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.PrefixLimit2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L2VpnEvpnValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L2VpnEvpnValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L2VpnEvpnValue) String() string {
	return "L2VpnEvpnValue"
}

func (v L2VpnEvpnValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimit2 basetypes.ObjectValue

	if v.PrefixLimit2.IsNull() {
		prefixLimit2 = types.ObjectNull(
			PrefixLimit2Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimit2.IsUnknown() {
		prefixLimit2 = types.ObjectUnknown(
			PrefixLimit2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimit2.IsNull() && !v.PrefixLimit2.IsUnknown() {
		prefixLimit2 = types.ObjectValueMust(
			PrefixLimit2Value{}.AttributeTypes(ctx),
			v.PrefixLimit2.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"advertise_ipv6_next_hops": basetypes.BoolType{},
		"enabled":                  basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertise_ipv6_next_hops": v.AdvertiseIpv6NextHops,
			"enabled":                  v.Enabled,
			"prefix_limit":             prefixLimit2,
		})

	return objVal, diags
}

func (v L2VpnEvpnValue) Equal(o attr.Value) bool {
	other, ok := o.(L2VpnEvpnValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertiseIpv6NextHops.Equal(other.AdvertiseIpv6NextHops) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.PrefixLimit2.Equal(other.PrefixLimit2) {
		return false
	}

	return true
}

func (v L2VpnEvpnValue) Type(ctx context.Context) attr.Type {
	return L2VpnEvpnType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L2VpnEvpnValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertise_ipv6_next_hops": basetypes.BoolType{},
		"enabled":                  basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimit2Type{}

type PrefixLimit2Type struct {
	basetypes.ObjectType
}

func (t PrefixLimit2Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimit2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimit2Type) String() string {
	return "PrefixLimit2Type"
}

func (t PrefixLimit2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixLimitAccepted2Attribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_2 is missing from object`)

		return nil, diags
	}

	prefixLimitAccepted2Val, ok := prefixLimitAccepted2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted2Attribute))
	}

	prefixLimitReceived2Attribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_2 is missing from object`)

		return nil, diags
	}

	prefixLimitReceived2Val, ok := prefixLimitReceived2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimit2Value{
		PrefixLimitAccepted2: prefixLimitAccepted2Val,
		PrefixLimitReceived2: prefixLimitReceived2Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit2ValueNull() PrefixLimit2Value {
	return PrefixLimit2Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimit2ValueUnknown() PrefixLimit2Value {
	return PrefixLimit2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimit2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimit2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimit2Value Attribute Value",
				"While creating a PrefixLimit2Value value, a missing attribute value was detected. "+
					"A PrefixLimit2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimit2Value Attribute Type",
				"While creating a PrefixLimit2Value value, an invalid attribute value was detected. "+
					"A PrefixLimit2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimit2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimit2Value Attribute Value",
				"While creating a PrefixLimit2Value value, an extra attribute value was detected. "+
					"A PrefixLimit2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimit2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimit2ValueUnknown(), diags
	}

	prefixLimitAccepted2Attribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_2 is missing from object`)

		return NewPrefixLimit2ValueUnknown(), diags
	}

	prefixLimitAccepted2Val, ok := prefixLimitAccepted2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted2Attribute))
	}

	prefixLimitReceived2Attribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_2 is missing from object`)

		return NewPrefixLimit2ValueUnknown(), diags
	}

	prefixLimitReceived2Val, ok := prefixLimitReceived2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived2Attribute))
	}

	if diags.HasError() {
		return NewPrefixLimit2ValueUnknown(), diags
	}

	return PrefixLimit2Value{
		PrefixLimitAccepted2: prefixLimitAccepted2Val,
		PrefixLimitReceived2: prefixLimitReceived2Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimit2Value {
	object, diags := NewPrefixLimit2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimit2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimit2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimit2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimit2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimit2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimit2ValueMust(PrefixLimit2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimit2Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimit2Value{}
}

var _ basetypes.ObjectValuable = PrefixLimit2Value{}

type PrefixLimit2Value struct {
	PrefixLimitAccepted2 basetypes.ObjectValue `tfsdk:"prefix_limit_accepted"`
	PrefixLimitReceived2 basetypes.ObjectValue `tfsdk:"prefix_limit_received"`
	state                attr.ValueState
}

func (v PrefixLimit2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["prefix_limit_accepted"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_limit_received"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PrefixLimitAccepted2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_accepted"] = val

		val, err = v.PrefixLimitReceived2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_received"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimit2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimit2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimit2Value) String() string {
	return "PrefixLimit2Value"
}

func (v PrefixLimit2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimitAccepted2 basetypes.ObjectValue

	if v.PrefixLimitAccepted2.IsNull() {
		prefixLimitAccepted2 = types.ObjectNull(
			PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitAccepted2.IsUnknown() {
		prefixLimitAccepted2 = types.ObjectUnknown(
			PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitAccepted2.IsNull() && !v.PrefixLimitAccepted2.IsUnknown() {
		prefixLimitAccepted2 = types.ObjectValueMust(
			PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
			v.PrefixLimitAccepted2.Attributes(),
		)
	}

	var prefixLimitReceived2 basetypes.ObjectValue

	if v.PrefixLimitReceived2.IsNull() {
		prefixLimitReceived2 = types.ObjectNull(
			PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitReceived2.IsUnknown() {
		prefixLimitReceived2 = types.ObjectUnknown(
			PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitReceived2.IsNull() && !v.PrefixLimitReceived2.IsUnknown() {
		prefixLimitReceived2 = types.ObjectValueMust(
			PrefixLimitReceived2Value{}.AttributeTypes(ctx),
			v.PrefixLimitReceived2.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix_limit_accepted": prefixLimitAccepted2,
			"prefix_limit_received": prefixLimitReceived2,
		})

	return objVal, diags
}

func (v PrefixLimit2Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimit2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PrefixLimitAccepted2.Equal(other.PrefixLimitAccepted2) {
		return false
	}

	if !v.PrefixLimitReceived2.Equal(other.PrefixLimitReceived2) {
		return false
	}

	return true
}

func (v PrefixLimit2Value) Type(ctx context.Context) attr.Type {
	return PrefixLimit2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimit2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitAccepted2Type{}

type PrefixLimitAccepted2Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitAccepted2Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitAccepted2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitAccepted2Type) String() string {
	return "PrefixLimitAccepted2Type"
}

func (t PrefixLimitAccepted2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitAccepted2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted2ValueNull() PrefixLimitAccepted2Value {
	return PrefixLimitAccepted2Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitAccepted2ValueUnknown() PrefixLimitAccepted2Value {
	return PrefixLimitAccepted2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitAccepted2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitAccepted2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitAccepted2Value Attribute Value",
				"While creating a PrefixLimitAccepted2Value value, a missing attribute value was detected. "+
					"A PrefixLimitAccepted2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitAccepted2Value Attribute Type",
				"While creating a PrefixLimitAccepted2Value value, an invalid attribute value was detected. "+
					"A PrefixLimitAccepted2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitAccepted2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitAccepted2Value Attribute Value",
				"While creating a PrefixLimitAccepted2Value value, an extra attribute value was detected. "+
					"A PrefixLimitAccepted2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitAccepted2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	return PrefixLimitAccepted2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitAccepted2Value {
	object, diags := NewPrefixLimitAccepted2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitAccepted2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitAccepted2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitAccepted2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitAccepted2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitAccepted2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitAccepted2ValueMust(PrefixLimitAccepted2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitAccepted2Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitAccepted2Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitAccepted2Value{}

type PrefixLimitAccepted2Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitAccepted2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitAccepted2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitAccepted2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitAccepted2Value) String() string {
	return "PrefixLimitAccepted2Value"
}

func (v PrefixLimitAccepted2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitAccepted2Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitAccepted2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitAccepted2Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitAccepted2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitAccepted2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitReceived2Type{}

type PrefixLimitReceived2Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitReceived2Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitReceived2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitReceived2Type) String() string {
	return "PrefixLimitReceived2Type"
}

func (t PrefixLimitReceived2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitReceived2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived2ValueNull() PrefixLimitReceived2Value {
	return PrefixLimitReceived2Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitReceived2ValueUnknown() PrefixLimitReceived2Value {
	return PrefixLimitReceived2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitReceived2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitReceived2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitReceived2Value Attribute Value",
				"While creating a PrefixLimitReceived2Value value, a missing attribute value was detected. "+
					"A PrefixLimitReceived2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitReceived2Value Attribute Type",
				"While creating a PrefixLimitReceived2Value value, an invalid attribute value was detected. "+
					"A PrefixLimitReceived2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitReceived2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitReceived2Value Attribute Value",
				"While creating a PrefixLimitReceived2Value value, an extra attribute value was detected. "+
					"A PrefixLimitReceived2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitReceived2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	return PrefixLimitReceived2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitReceived2Value {
	object, diags := NewPrefixLimitReceived2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitReceived2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitReceived2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitReceived2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitReceived2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitReceived2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitReceived2ValueMust(PrefixLimitReceived2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitReceived2Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitReceived2Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitReceived2Value{}

type PrefixLimitReceived2Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitReceived2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitReceived2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitReceived2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitReceived2Value) String() string {
	return "PrefixLimitReceived2Value"
}

func (v PrefixLimitReceived2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitReceived2Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitReceived2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitReceived2Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitReceived2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitReceived2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LocalAsType{}

type LocalAsType struct {
	basetypes.ObjectType
}

func (t LocalAsType) Equal(o attr.Type) bool {
	other, ok := o.(LocalAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalAsType) String() string {
	return "LocalAsType"
}

func (t LocalAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return nil, diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	prependGlobalAsAttribute, ok := attributes["prepend_global_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_global_as is missing from object`)

		return nil, diags
	}

	prependGlobalAsVal, ok := prependGlobalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_global_as expected to be basetypes.BoolValue, was: %T`, prependGlobalAsAttribute))
	}

	prependLocalAsAttribute, ok := attributes["prepend_local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_local_as is missing from object`)

		return nil, diags
	}

	prependLocalAsVal, ok := prependLocalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_local_as expected to be basetypes.BoolValue, was: %T`, prependLocalAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalAsValue{
		AutonomousSystem: autonomousSystemVal,
		PrependGlobalAs:  prependGlobalAsVal,
		PrependLocalAs:   prependLocalAsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalAsValueNull() LocalAsValue {
	return LocalAsValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalAsValueUnknown() LocalAsValue {
	return LocalAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalAsValue Attribute Value",
				"While creating a LocalAsValue value, a missing attribute value was detected. "+
					"A LocalAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalAsValue Attribute Type",
				"While creating a LocalAsValue value, an invalid attribute value was detected. "+
					"A LocalAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalAsValue Attribute Value",
				"While creating a LocalAsValue value, an extra attribute value was detected. "+
					"A LocalAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalAsValueUnknown(), diags
	}

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	prependGlobalAsAttribute, ok := attributes["prepend_global_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_global_as is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	prependGlobalAsVal, ok := prependGlobalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_global_as expected to be basetypes.BoolValue, was: %T`, prependGlobalAsAttribute))
	}

	prependLocalAsAttribute, ok := attributes["prepend_local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_local_as is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	prependLocalAsVal, ok := prependLocalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_local_as expected to be basetypes.BoolValue, was: %T`, prependLocalAsAttribute))
	}

	if diags.HasError() {
		return NewLocalAsValueUnknown(), diags
	}

	return LocalAsValue{
		AutonomousSystem: autonomousSystemVal,
		PrependGlobalAs:  prependGlobalAsVal,
		PrependLocalAs:   prependLocalAsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalAsValue {
	object, diags := NewLocalAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalAsValueMust(LocalAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalAsType) ValueType(ctx context.Context) attr.Value {
	return LocalAsValue{}
}

var _ basetypes.ObjectValuable = LocalAsValue{}

type LocalAsValue struct {
	AutonomousSystem basetypes.Int64Value `tfsdk:"autonomous_system"`
	PrependGlobalAs  basetypes.BoolValue  `tfsdk:"prepend_global_as"`
	PrependLocalAs   basetypes.BoolValue  `tfsdk:"prepend_local_as"`
	state            attr.ValueState
}

func (v LocalAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prepend_global_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prepend_local_as"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_system"] = val

		val, err = v.PrependGlobalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepend_global_as"] = val

		val, err = v.PrependLocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepend_local_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalAsValue) String() string {
	return "LocalAsValue"
}

func (v LocalAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"prepend_global_as": basetypes.BoolType{},
		"prepend_local_as":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_system": v.AutonomousSystem,
			"prepend_global_as": v.PrependGlobalAs,
			"prepend_local_as":  v.PrependLocalAs,
		})

	return objVal, diags
}

func (v LocalAsValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousSystem.Equal(other.AutonomousSystem) {
		return false
	}

	if !v.PrependGlobalAs.Equal(other.PrependGlobalAs) {
		return false
	}

	if !v.PrependLocalAs.Equal(other.PrependLocalAs) {
		return false
	}

	return true
}

func (v LocalAsValue) Type(ctx context.Context) attr.Type {
	return LocalAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"prepend_global_as": basetypes.BoolType{},
		"prepend_local_as":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PeerAsType{}

type PeerAsType struct {
	basetypes.ObjectType
}

func (t PeerAsType) Equal(o attr.Type) bool {
	other, ok := o.(PeerAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PeerAsType) String() string {
	return "PeerAsType"
}

func (t PeerAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return nil, diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PeerAsValue{
		AutonomousSystem: autonomousSystemVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPeerAsValueNull() PeerAsValue {
	return PeerAsValue{
		state: attr.ValueStateNull,
	}
}

func NewPeerAsValueUnknown() PeerAsValue {
	return PeerAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPeerAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PeerAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PeerAsValue Attribute Value",
				"While creating a PeerAsValue value, a missing attribute value was detected. "+
					"A PeerAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PeerAsValue Attribute Type",
				"While creating a PeerAsValue value, an invalid attribute value was detected. "+
					"A PeerAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PeerAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PeerAsValue Attribute Value",
				"While creating a PeerAsValue value, an extra attribute value was detected. "+
					"A PeerAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PeerAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPeerAsValueUnknown(), diags
	}

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return NewPeerAsValueUnknown(), diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	if diags.HasError() {
		return NewPeerAsValueUnknown(), diags
	}

	return PeerAsValue{
		AutonomousSystem: autonomousSystemVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPeerAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PeerAsValue {
	object, diags := NewPeerAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPeerAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PeerAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPeerAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPeerAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPeerAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPeerAsValueMust(PeerAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PeerAsType) ValueType(ctx context.Context) attr.Value {
	return PeerAsValue{}
}

var _ basetypes.ObjectValuable = PeerAsValue{}

type PeerAsValue struct {
	AutonomousSystem basetypes.Int64Value `tfsdk:"autonomous_system"`
	state            attr.ValueState
}

func (v PeerAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.AutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_system"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PeerAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PeerAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PeerAsValue) String() string {
	return "PeerAsValue"
}

func (v PeerAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_system": v.AutonomousSystem,
		})

	return objVal, diags
}

func (v PeerAsValue) Equal(o attr.Value) bool {
	other, ok := o.(PeerAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousSystem.Equal(other.AutonomousSystem) {
		return false
	}

	return true
}

func (v PeerAsValue) Type(ctx context.Context) attr.Type {
	return PeerAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PeerAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RtcType{}

type RtcType struct {
	basetypes.ObjectType
}

func (t RtcType) Equal(o attr.Type) bool {
	other, ok := o.(RtcType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RtcType) String() string {
	return "RtcType"
}

func (t RtcType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertiseDefaultRouteAttribute, ok := attributes["advertise_default_route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_default_route is missing from object`)

		return nil, diags
	}

	advertiseDefaultRouteVal, ok := advertiseDefaultRouteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_default_route expected to be basetypes.BoolValue, was: %T`, advertiseDefaultRouteAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RtcValue{
		AdvertiseDefaultRoute: advertiseDefaultRouteVal,
		Enabled:               enabledVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewRtcValueNull() RtcValue {
	return RtcValue{
		state: attr.ValueStateNull,
	}
}

func NewRtcValueUnknown() RtcValue {
	return RtcValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRtcValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RtcValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RtcValue Attribute Value",
				"While creating a RtcValue value, a missing attribute value was detected. "+
					"A RtcValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RtcValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RtcValue Attribute Type",
				"While creating a RtcValue value, an invalid attribute value was detected. "+
					"A RtcValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RtcValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RtcValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RtcValue Attribute Value",
				"While creating a RtcValue value, an extra attribute value was detected. "+
					"A RtcValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RtcValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRtcValueUnknown(), diags
	}

	advertiseDefaultRouteAttribute, ok := attributes["advertise_default_route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_default_route is missing from object`)

		return NewRtcValueUnknown(), diags
	}

	advertiseDefaultRouteVal, ok := advertiseDefaultRouteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_default_route expected to be basetypes.BoolValue, was: %T`, advertiseDefaultRouteAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewRtcValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewRtcValueUnknown(), diags
	}

	return RtcValue{
		AdvertiseDefaultRoute: advertiseDefaultRouteVal,
		Enabled:               enabledVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewRtcValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RtcValue {
	object, diags := NewRtcValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRtcValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RtcType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRtcValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRtcValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRtcValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRtcValueMust(RtcValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RtcType) ValueType(ctx context.Context) attr.Value {
	return RtcValue{}
}

var _ basetypes.ObjectValuable = RtcValue{}

type RtcValue struct {
	AdvertiseDefaultRoute basetypes.BoolValue `tfsdk:"advertise_default_route"`
	Enabled               basetypes.BoolValue `tfsdk:"enabled"`
	state                 attr.ValueState
}

func (v RtcValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["advertise_default_route"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AdvertiseDefaultRoute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertise_default_route"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RtcValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RtcValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RtcValue) String() string {
	return "RtcValue"
}

func (v RtcValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"advertise_default_route": basetypes.BoolType{},
		"enabled":                 basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertise_default_route": v.AdvertiseDefaultRoute,
			"enabled":                 v.Enabled,
		})

	return objVal, diags
}

func (v RtcValue) Equal(o attr.Value) bool {
	other, ok := o.(RtcValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertiseDefaultRoute.Equal(other.AdvertiseDefaultRoute) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v RtcValue) Type(ctx context.Context) attr.Type {
	return RtcType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RtcValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertise_default_route": basetypes.BoolType{},
		"enabled":                 basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SendDefaultRouteType{}

type SendDefaultRouteType struct {
	basetypes.ObjectType
}

func (t SendDefaultRouteType) Equal(o attr.Type) bool {
	other, ok := o.(SendDefaultRouteType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SendDefaultRouteType) String() string {
	return "SendDefaultRouteType"
}

func (t SendDefaultRouteType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return nil, diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.ListValue, was: %T`, addressFamilyAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SendDefaultRouteValue{
		AddressFamily: addressFamilyVal,
		ExportPolicy:  exportPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSendDefaultRouteValueNull() SendDefaultRouteValue {
	return SendDefaultRouteValue{
		state: attr.ValueStateNull,
	}
}

func NewSendDefaultRouteValueUnknown() SendDefaultRouteValue {
	return SendDefaultRouteValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSendDefaultRouteValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SendDefaultRouteValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SendDefaultRouteValue Attribute Value",
				"While creating a SendDefaultRouteValue value, a missing attribute value was detected. "+
					"A SendDefaultRouteValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SendDefaultRouteValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SendDefaultRouteValue Attribute Type",
				"While creating a SendDefaultRouteValue value, an invalid attribute value was detected. "+
					"A SendDefaultRouteValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SendDefaultRouteValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SendDefaultRouteValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SendDefaultRouteValue Attribute Value",
				"While creating a SendDefaultRouteValue value, an extra attribute value was detected. "+
					"A SendDefaultRouteValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SendDefaultRouteValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSendDefaultRouteValueUnknown(), diags
	}

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return NewSendDefaultRouteValueUnknown(), diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.ListValue, was: %T`, addressFamilyAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewSendDefaultRouteValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	if diags.HasError() {
		return NewSendDefaultRouteValueUnknown(), diags
	}

	return SendDefaultRouteValue{
		AddressFamily: addressFamilyVal,
		ExportPolicy:  exportPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSendDefaultRouteValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SendDefaultRouteValue {
	object, diags := NewSendDefaultRouteValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSendDefaultRouteValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SendDefaultRouteType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSendDefaultRouteValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSendDefaultRouteValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSendDefaultRouteValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSendDefaultRouteValueMust(SendDefaultRouteValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SendDefaultRouteType) ValueType(ctx context.Context) attr.Value {
	return SendDefaultRouteValue{}
}

var _ basetypes.ObjectValuable = SendDefaultRouteValue{}

type SendDefaultRouteValue struct {
	AddressFamily basetypes.ListValue   `tfsdk:"address_family"`
	ExportPolicy  basetypes.StringValue `tfsdk:"export_policy"`
	state         attr.ValueState
}

func (v SendDefaultRouteValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["address_family"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AddressFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_family"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SendDefaultRouteValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SendDefaultRouteValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SendDefaultRouteValue) String() string {
	return "SendDefaultRouteValue"
}

func (v SendDefaultRouteValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var addressFamilyVal basetypes.ListValue
	switch {
	case v.AddressFamily.IsUnknown():
		addressFamilyVal = types.ListUnknown(types.StringType)
	case v.AddressFamily.IsNull():
		addressFamilyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addressFamilyVal, d = types.ListValue(types.StringType, v.AddressFamily.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_family": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_policy": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address_family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_family": addressFamilyVal,
			"export_policy":  v.ExportPolicy,
		})

	return objVal, diags
}

func (v SendDefaultRouteValue) Equal(o attr.Value) bool {
	other, ok := o.(SendDefaultRouteValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressFamily.Equal(other.AddressFamily) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	return true
}

func (v SendDefaultRouteValue) Type(ctx context.Context) attr.Type {
	return SendDefaultRouteType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SendDefaultRouteValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TimersType{}

type TimersType struct {
	basetypes.ObjectType
}

func (t TimersType) Equal(o attr.Type) bool {
	other, ok := o.(TimersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TimersType) String() string {
	return "TimersType"
}

func (t TimersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return nil, diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return nil, diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return nil, diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TimersValue{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimersValueNull() TimersValue {
	return TimersValue{
		state: attr.ValueStateNull,
	}
}

func NewTimersValueUnknown() TimersValue {
	return TimersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTimersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TimersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TimersValue Attribute Value",
				"While creating a TimersValue value, a missing attribute value was detected. "+
					"A TimersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TimersValue Attribute Type",
				"While creating a TimersValue value, an invalid attribute value was detected. "+
					"A TimersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TimersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TimersValue Attribute Value",
				"While creating a TimersValue value, an extra attribute value was detected. "+
					"A TimersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TimersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimersValueUnknown(), diags
	}

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return NewTimersValueUnknown(), diags
	}

	return TimersValue{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TimersValue {
	object, diags := NewTimersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TimersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimersValueMust(TimersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TimersType) ValueType(ctx context.Context) attr.Value {
	return TimersValue{}
}

var _ basetypes.ObjectValuable = TimersValue{}

type TimersValue struct {
	ConnectRetry                 basetypes.Int64Value `tfsdk:"connect_retry"`
	HoldTime                     basetypes.Int64Value `tfsdk:"hold_time"`
	KeepAlive                    basetypes.Int64Value `tfsdk:"keep_alive"`
	MinimumAdvertisementInterval basetypes.Int64Value `tfsdk:"minimum_advertisement_interval"`
	state                        attr.ValueState
}

func (v TimersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["connect_retry"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_alive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minimum_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ConnectRetry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connect_retry"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.KeepAlive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_alive"] = val

		val, err = v.MinimumAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimum_advertisement_interval"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TimersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TimersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TimersValue) String() string {
	return "TimersValue"
}

func (v TimersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connect_retry":                  v.ConnectRetry,
			"hold_time":                      v.HoldTime,
			"keep_alive":                     v.KeepAlive,
			"minimum_advertisement_interval": v.MinimumAdvertisementInterval,
		})

	return objVal, diags
}

func (v TimersValue) Equal(o attr.Value) bool {
	other, ok := o.(TimersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConnectRetry.Equal(other.ConnectRetry) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.KeepAlive.Equal(other.KeepAlive) {
		return false
	}

	if !v.MinimumAdvertisementInterval.Equal(other.MinimumAdvertisementInterval) {
		return false
	}

	return true
}

func (v TimersValue) Type(ctx context.Context) attr.Type {
	return TimersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TimersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	lastEventAttribute, ok := attributes["last_event"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_event is missing from object`)

		return nil, diags
	}

	lastEventVal, ok := lastEventAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_event expected to be basetypes.StringValue, was: %T`, lastEventAttribute))
	}

	lastStateAttribute, ok := attributes["last_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_state is missing from object`)

		return nil, diags
	}

	lastStateVal, ok := lastStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_state expected to be basetypes.StringValue, was: %T`, lastStateAttribute))
	}

	negotiatedHoldTimeAttribute, ok := attributes["negotiated_hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`negotiated_hold_time is missing from object`)

		return nil, diags
	}

	negotiatedHoldTimeVal, ok := negotiatedHoldTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`negotiated_hold_time expected to be basetypes.Int64Value, was: %T`, negotiatedHoldTimeAttribute))
	}

	negotiatedKeepaliveIntervalAttribute, ok := attributes["negotiated_keepalive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`negotiated_keepalive_interval is missing from object`)

		return nil, diags
	}

	negotiatedKeepaliveIntervalVal, ok := negotiatedKeepaliveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`negotiated_keepalive_interval expected to be basetypes.Int64Value, was: %T`, negotiatedKeepaliveIntervalAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	peerAsAttribute, ok := attributes["peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_as is missing from object`)

		return nil, diags
	}

	peerAsVal, ok := peerAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_as expected to be basetypes.Int64Value, was: %T`, peerAsAttribute))
	}

	sessionStateAttribute, ok := attributes["session_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`session_state is missing from object`)

		return nil, diags
	}

	sessionStateVal, ok := sessionStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`session_state expected to be basetypes.StringValue, was: %T`, sessionStateAttribute))
	}

	underMaintenanceAttribute, ok := attributes["under_maintenance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`under_maintenance is missing from object`)

		return nil, diags
	}

	underMaintenanceVal, ok := underMaintenanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`under_maintenance expected to be basetypes.BoolValue, was: %T`, underMaintenanceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Enabled:                     enabledVal,
		Health:                      healthVal,
		HealthScoreReason:           healthScoreReasonVal,
		LastChange:                  lastChangeVal,
		LastEvent:                   lastEventVal,
		LastState:                   lastStateVal,
		NegotiatedHoldTime:          negotiatedHoldTimeVal,
		NegotiatedKeepaliveInterval: negotiatedKeepaliveIntervalVal,
		OperationalState:            operationalStateVal,
		PeerAs:                      peerAsVal,
		SessionState:                sessionStateVal,
		UnderMaintenance:            underMaintenanceVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	lastEventAttribute, ok := attributes["last_event"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_event is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastEventVal, ok := lastEventAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_event expected to be basetypes.StringValue, was: %T`, lastEventAttribute))
	}

	lastStateAttribute, ok := attributes["last_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastStateVal, ok := lastStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_state expected to be basetypes.StringValue, was: %T`, lastStateAttribute))
	}

	negotiatedHoldTimeAttribute, ok := attributes["negotiated_hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`negotiated_hold_time is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	negotiatedHoldTimeVal, ok := negotiatedHoldTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`negotiated_hold_time expected to be basetypes.Int64Value, was: %T`, negotiatedHoldTimeAttribute))
	}

	negotiatedKeepaliveIntervalAttribute, ok := attributes["negotiated_keepalive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`negotiated_keepalive_interval is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	negotiatedKeepaliveIntervalVal, ok := negotiatedKeepaliveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`negotiated_keepalive_interval expected to be basetypes.Int64Value, was: %T`, negotiatedKeepaliveIntervalAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	peerAsAttribute, ok := attributes["peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_as is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	peerAsVal, ok := peerAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_as expected to be basetypes.Int64Value, was: %T`, peerAsAttribute))
	}

	sessionStateAttribute, ok := attributes["session_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`session_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	sessionStateVal, ok := sessionStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`session_state expected to be basetypes.StringValue, was: %T`, sessionStateAttribute))
	}

	underMaintenanceAttribute, ok := attributes["under_maintenance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`under_maintenance is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	underMaintenanceVal, ok := underMaintenanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`under_maintenance expected to be basetypes.BoolValue, was: %T`, underMaintenanceAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Enabled:                     enabledVal,
		Health:                      healthVal,
		HealthScoreReason:           healthScoreReasonVal,
		LastChange:                  lastChangeVal,
		LastEvent:                   lastEventVal,
		LastState:                   lastStateVal,
		NegotiatedHoldTime:          negotiatedHoldTimeVal,
		NegotiatedKeepaliveInterval: negotiatedKeepaliveIntervalVal,
		OperationalState:            operationalStateVal,
		PeerAs:                      peerAsVal,
		SessionState:                sessionStateVal,
		UnderMaintenance:            underMaintenanceVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Enabled                     basetypes.BoolValue   `tfsdk:"enabled"`
	Health                      basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason           basetypes.StringValue `tfsdk:"health_score_reason"`
	LastChange                  basetypes.StringValue `tfsdk:"last_change"`
	LastEvent                   basetypes.StringValue `tfsdk:"last_event"`
	LastState                   basetypes.StringValue `tfsdk:"last_state"`
	NegotiatedHoldTime          basetypes.Int64Value  `tfsdk:"negotiated_hold_time"`
	NegotiatedKeepaliveInterval basetypes.Int64Value  `tfsdk:"negotiated_keepalive_interval"`
	OperationalState            basetypes.StringValue `tfsdk:"operational_state"`
	PeerAs                      basetypes.Int64Value  `tfsdk:"peer_as"`
	SessionState                basetypes.StringValue `tfsdk:"session_state"`
	UnderMaintenance            basetypes.BoolValue   `tfsdk:"under_maintenance"`
	state                       attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_event"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["negotiated_hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["negotiated_keepalive_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["peer_as"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["session_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["under_maintenance"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.LastEvent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_event"] = val

		val, err = v.LastState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_state"] = val

		val, err = v.NegotiatedHoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["negotiated_hold_time"] = val

		val, err = v.NegotiatedKeepaliveInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["negotiated_keepalive_interval"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.PeerAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_as"] = val

		val, err = v.SessionState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["session_state"] = val

		val, err = v.UnderMaintenance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["under_maintenance"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":                       basetypes.BoolType{},
		"health":                        basetypes.Int64Type{},
		"health_score_reason":           basetypes.StringType{},
		"last_change":                   basetypes.StringType{},
		"last_event":                    basetypes.StringType{},
		"last_state":                    basetypes.StringType{},
		"negotiated_hold_time":          basetypes.Int64Type{},
		"negotiated_keepalive_interval": basetypes.Int64Type{},
		"operational_state":             basetypes.StringType{},
		"peer_as":                       basetypes.Int64Type{},
		"session_state":                 basetypes.StringType{},
		"under_maintenance":             basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":                       v.Enabled,
			"health":                        v.Health,
			"health_score_reason":           v.HealthScoreReason,
			"last_change":                   v.LastChange,
			"last_event":                    v.LastEvent,
			"last_state":                    v.LastState,
			"negotiated_hold_time":          v.NegotiatedHoldTime,
			"negotiated_keepalive_interval": v.NegotiatedKeepaliveInterval,
			"operational_state":             v.OperationalState,
			"peer_as":                       v.PeerAs,
			"session_state":                 v.SessionState,
			"under_maintenance":             v.UnderMaintenance,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.LastEvent.Equal(other.LastEvent) {
		return false
	}

	if !v.LastState.Equal(other.LastState) {
		return false
	}

	if !v.NegotiatedHoldTime.Equal(other.NegotiatedHoldTime) {
		return false
	}

	if !v.NegotiatedKeepaliveInterval.Equal(other.NegotiatedKeepaliveInterval) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.PeerAs.Equal(other.PeerAs) {
		return false
	}

	if !v.SessionState.Equal(other.SessionState) {
		return false
	}

	if !v.UnderMaintenance.Equal(other.UnderMaintenance) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":                       basetypes.BoolType{},
		"health":                        basetypes.Int64Type{},
		"health_score_reason":           basetypes.StringType{},
		"last_change":                   basetypes.StringType{},
		"last_event":                    basetypes.StringType{},
		"last_state":                    basetypes.StringType{},
		"negotiated_hold_time":          basetypes.Int64Type{},
		"negotiated_keepalive_interval": basetypes.Int64Type{},
		"operational_state":             basetypes.StringType{},
		"peer_as":                       basetypes.Int64Type{},
		"session_state":                 basetypes.StringType{},
		"under_maintenance":             basetypes.BoolType{},
	}
}
