// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_static_route

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func StaticRouteDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"hash": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "resource content will be returned as it was at the time of this git hash",
				MarkdownDescription: "resource content will be returned as it was at the time of this git hash",
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"namespace": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "name of the StaticRoute",
				MarkdownDescription: "name of the StaticRoute",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"nexthop_group": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"bfd": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"enabled": schema.BoolAttribute{
										Optional:            true,
										Description:         "Defines whether BFD should be enabled towards the nexthops.",
										MarkdownDescription: "Defines whether BFD should be enabled towards the nexthops.",
									},
									"local_address": schema.StringAttribute{
										Optional:            true,
										Description:         "Defines the local address to use when establishing the BFD session with the nexthop.",
										MarkdownDescription: "Defines the local address to use when establishing the BFD session with the nexthop.",
									},
								},
								CustomType: BfdType{
									ObjectType: types.ObjectType{
										AttrTypes: BfdValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Enables BFD to the next-hops in the group. Local and Remote discriminator parameters have been deprecated at this level. Use Nexthop to set these parameters.",
								MarkdownDescription: "Enables BFD to the next-hops in the group. Local and Remote discriminator parameters have been deprecated at this level. Use Nexthop to set these parameters.",
							},
							"blackhole": schema.BoolAttribute{
								Optional:            true,
								Description:         "If set to true all traffic destined to the prefixes will be blackholed.  If enabled, next-hops are ignored and this takes precedence.",
								MarkdownDescription: "If set to true all traffic destined to the prefixes will be blackholed.  If enabled, next-hops are ignored and this takes precedence.",
							},
							"blackhole_send_icmp": schema.BoolAttribute{
								Optional:            true,
								Description:         "When enabled, the router will generate ICMP Unreachable messages for packets destined to the blackhole route.",
								MarkdownDescription: "When enabled, the router will generate ICMP Unreachable messages for packets destined to the blackhole route.",
							},
							"nexthops": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"bfd_1": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"enabled": schema.BoolAttribute{
													Optional:            true,
													Description:         "Defines whether BFD should be enabled towards the nexthops.",
													MarkdownDescription: "Defines whether BFD should be enabled towards the nexthops.",
												},
												"local_address": schema.StringAttribute{
													Optional:            true,
													Description:         "Defines the local address to use when establishing the BFD session with the nexthop.",
													MarkdownDescription: "Defines the local address to use when establishing the BFD session with the nexthop.",
												},
												"local_discriminator": schema.Int64Attribute{
													Optional:            true,
													Description:         "Defines the local discriminator.",
													MarkdownDescription: "Defines the local discriminator.",
												},
												"remote_discriminator": schema.Int64Attribute{
													Optional:            true,
													Description:         "Defines the remote discriminator.",
													MarkdownDescription: "Defines the remote discriminator.",
												},
											},
											CustomType: Bfd1Type{
												ObjectType: types.ObjectType{
													AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
												},
											},
											Optional:            true,
											Description:         "Enables BFD to the next-hops in the group. This overrides the configuration at the group.",
											MarkdownDescription: "Enables BFD to the next-hops in the group. This overrides the configuration at the group.",
										},
										"ip_prefix": schema.StringAttribute{
											Optional:            true,
											Description:         "Address to use.",
											MarkdownDescription: "Address to use.",
										},
										"resolve": schema.BoolAttribute{
											Optional:            true,
											Description:         "If set to true the next-hops can be destinations which are resolved in the route table. This overrides the configuration at the group.",
											MarkdownDescription: "If set to true the next-hops can be destinations which are resolved in the route table. This overrides the configuration at the group.",
										},
									},
									CustomType: NexthopsType{
										ObjectType: types.ObjectType{
											AttrTypes: NexthopsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "Ordered list of nexthops.",
								MarkdownDescription: "Ordered list of nexthops.",
							},
							"resolve": schema.BoolAttribute{
								Optional:            true,
								Description:         "If set to true the next-hops can be destinations which are resolved in the route table.",
								MarkdownDescription: "If set to true the next-hops can be destinations which are resolved in the route table.",
							},
						},
						CustomType: NexthopGroupType{
							ObjectType: types.ObjectType{
								AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Group of nexthops for the list of prefixes.",
						MarkdownDescription: "Group of nexthops for the list of prefixes.",
					},
					"nodes": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of nodes on which to configure the static routes. An AND operation is executed against the nodes in this list and the nodes on which the Router is configured to determine the Nodes on which to configure the static routes.",
						MarkdownDescription: "List of nodes on which to configure the static routes. An AND operation is executed against the nodes in this list and the nodes on which the Router is configured to determine the Nodes on which to configure the static routes.",
					},
					"preference": schema.Int64Attribute{
						Optional:            true,
						Description:         "Defines the route preference.",
						MarkdownDescription: "Defines the route preference.",
					},
					"prefixes": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of destination prefixes and mask to use for the static routes.",
						MarkdownDescription: "List of destination prefixes and mask to use for the static routes.",
					},
					"router": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a Router on which to configure the static routes.  If no Nodes are provided then the static routes will be provisioned on all Nodes on which the Router is provisioned.",
						MarkdownDescription: "Reference to a Router on which to configure the static routes.  If no Nodes are provided then the static routes will be provisioned on all Nodes on which the Router is provisioned.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "StaticRoute allows for the specification of destination prefixes, route preferences, and the associated Router. It also supports configuring nexthop groups and specifying the nodes where the static routes should be provisioned.",
				MarkdownDescription: "StaticRoute allows for the specification of destination prefixes, route preferences, and the associated Router. It also supports configuring nexthop groups and specifying the nodes where the static routes should be provisioned.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"health": schema.Int64Attribute{
						Computed:            true,
						Description:         "Indicates the health score of the static routes.",
						MarkdownDescription: "Indicates the health score of the static routes.",
					},
					"health_score_reason": schema.StringAttribute{
						Computed:            true,
						Description:         "Indicates the reason for the health score.",
						MarkdownDescription: "Indicates the reason for the health score.",
					},
					"last_change": schema.StringAttribute{
						Computed:            true,
						Description:         "The time when the state of the resource last changed.",
						MarkdownDescription: "The time when the state of the resource last changed.",
					},
					"nodes": schema.ListAttribute{
						ElementType:         types.StringType,
						Computed:            true,
						Description:         "List of Nodes on which the static routes are configured.",
						MarkdownDescription: "List of Nodes on which the static routes are configured.",
					},
					"operational_state": schema.StringAttribute{
						Computed:            true,
						Description:         "Operational state of the static routes.",
						MarkdownDescription: "Operational state of the static routes.",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "StaticRouteStatus defines the observed state of Static Route",
				MarkdownDescription: "StaticRouteStatus defines the observed state of Static Route",
			},
		},
	}
}

type StaticRouteModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Hash       types.String  `tfsdk:"hash"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nexthopGroupAttribute, ok := attributes["nexthop_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nexthop_group is missing from object`)

		return nil, diags
	}

	nexthopGroupVal, ok := nexthopGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nexthop_group expected to be basetypes.ObjectValue, was: %T`, nexthopGroupAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	prefixesAttribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes is missing from object`)

		return nil, diags
	}

	prefixesVal, ok := prefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes expected to be basetypes.ListValue, was: %T`, prefixesAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return nil, diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		NexthopGroup: nexthopGroupVal,
		Nodes:        nodesVal,
		Preference:   preferenceVal,
		Prefixes:     prefixesVal,
		Router:       routerVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	nexthopGroupAttribute, ok := attributes["nexthop_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nexthop_group is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nexthopGroupVal, ok := nexthopGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nexthop_group expected to be basetypes.ObjectValue, was: %T`, nexthopGroupAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	prefixesAttribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	prefixesVal, ok := prefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes expected to be basetypes.ListValue, was: %T`, prefixesAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		NexthopGroup: nexthopGroupVal,
		Nodes:        nodesVal,
		Preference:   preferenceVal,
		Prefixes:     prefixesVal,
		Router:       routerVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	NexthopGroup basetypes.ObjectValue `tfsdk:"nexthop_group"`
	Nodes        basetypes.ListValue   `tfsdk:"nodes"`
	Preference   basetypes.Int64Value  `tfsdk:"preference"`
	Prefixes     basetypes.ListValue   `tfsdk:"prefixes"`
	Router       basetypes.StringValue `tfsdk:"router"`
	state        attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["nexthop_group"] = basetypes.ObjectType{
		AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prefixes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["router"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.NexthopGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nexthop_group"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		val, err = v.Prefixes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefixes"] = val

		val, err = v.Router.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var nexthopGroup basetypes.ObjectValue

	if v.NexthopGroup.IsNull() {
		nexthopGroup = types.ObjectNull(
			NexthopGroupValue{}.AttributeTypes(ctx),
		)
	}

	if v.NexthopGroup.IsUnknown() {
		nexthopGroup = types.ObjectUnknown(
			NexthopGroupValue{}.AttributeTypes(ctx),
		)
	}

	if !v.NexthopGroup.IsNull() && !v.NexthopGroup.IsUnknown() {
		nexthopGroup = types.ObjectValueMust(
			NexthopGroupValue{}.AttributeTypes(ctx),
			v.NexthopGroup.Attributes(),
		)
	}

	var nodesVal basetypes.ListValue
	switch {
	case v.Nodes.IsUnknown():
		nodesVal = types.ListUnknown(types.StringType)
	case v.Nodes.IsNull():
		nodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodesVal, d = types.ListValue(types.StringType, v.Nodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"nexthop_group": basetypes.ObjectType{
				AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"preference": basetypes.Int64Type{},
			"prefixes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"router": basetypes.StringType{},
		}), diags
	}

	var prefixesVal basetypes.ListValue
	switch {
	case v.Prefixes.IsUnknown():
		prefixesVal = types.ListUnknown(types.StringType)
	case v.Prefixes.IsNull():
		prefixesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		prefixesVal, d = types.ListValue(types.StringType, v.Prefixes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"nexthop_group": basetypes.ObjectType{
				AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"preference": basetypes.Int64Type{},
			"prefixes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"router": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"nexthop_group": basetypes.ObjectType{
			AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"preference": basetypes.Int64Type{},
		"prefixes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"router": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"nexthop_group": nexthopGroup,
			"nodes":         nodesVal,
			"preference":    v.Preference,
			"prefixes":      prefixesVal,
			"router":        v.Router,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NexthopGroup.Equal(other.NexthopGroup) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	if !v.Prefixes.Equal(other.Prefixes) {
		return false
	}

	if !v.Router.Equal(other.Router) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"nexthop_group": basetypes.ObjectType{
			AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"preference": basetypes.Int64Type{},
		"prefixes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"router": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NexthopGroupType{}

type NexthopGroupType struct {
	basetypes.ObjectType
}

func (t NexthopGroupType) Equal(o attr.Type) bool {
	other, ok := o.(NexthopGroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NexthopGroupType) String() string {
	return "NexthopGroupType"
}

func (t NexthopGroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return nil, diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	blackholeAttribute, ok := attributes["blackhole"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blackhole is missing from object`)

		return nil, diags
	}

	blackholeVal, ok := blackholeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blackhole expected to be basetypes.BoolValue, was: %T`, blackholeAttribute))
	}

	blackholeSendIcmpAttribute, ok := attributes["blackhole_send_icmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blackhole_send_icmp is missing from object`)

		return nil, diags
	}

	blackholeSendIcmpVal, ok := blackholeSendIcmpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blackhole_send_icmp expected to be basetypes.BoolValue, was: %T`, blackholeSendIcmpAttribute))
	}

	nexthopsAttribute, ok := attributes["nexthops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nexthops is missing from object`)

		return nil, diags
	}

	nexthopsVal, ok := nexthopsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nexthops expected to be basetypes.ListValue, was: %T`, nexthopsAttribute))
	}

	resolveAttribute, ok := attributes["resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resolve is missing from object`)

		return nil, diags
	}

	resolveVal, ok := resolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resolve expected to be basetypes.BoolValue, was: %T`, resolveAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NexthopGroupValue{
		Bfd:               bfdVal,
		Blackhole:         blackholeVal,
		BlackholeSendIcmp: blackholeSendIcmpVal,
		Nexthops:          nexthopsVal,
		Resolve:           resolveVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNexthopGroupValueNull() NexthopGroupValue {
	return NexthopGroupValue{
		state: attr.ValueStateNull,
	}
}

func NewNexthopGroupValueUnknown() NexthopGroupValue {
	return NexthopGroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNexthopGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NexthopGroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NexthopGroupValue Attribute Value",
				"While creating a NexthopGroupValue value, a missing attribute value was detected. "+
					"A NexthopGroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NexthopGroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NexthopGroupValue Attribute Type",
				"While creating a NexthopGroupValue value, an invalid attribute value was detected. "+
					"A NexthopGroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NexthopGroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NexthopGroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NexthopGroupValue Attribute Value",
				"While creating a NexthopGroupValue value, an extra attribute value was detected. "+
					"A NexthopGroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NexthopGroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNexthopGroupValueUnknown(), diags
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return NewNexthopGroupValueUnknown(), diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	blackholeAttribute, ok := attributes["blackhole"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blackhole is missing from object`)

		return NewNexthopGroupValueUnknown(), diags
	}

	blackholeVal, ok := blackholeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blackhole expected to be basetypes.BoolValue, was: %T`, blackholeAttribute))
	}

	blackholeSendIcmpAttribute, ok := attributes["blackhole_send_icmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blackhole_send_icmp is missing from object`)

		return NewNexthopGroupValueUnknown(), diags
	}

	blackholeSendIcmpVal, ok := blackholeSendIcmpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blackhole_send_icmp expected to be basetypes.BoolValue, was: %T`, blackholeSendIcmpAttribute))
	}

	nexthopsAttribute, ok := attributes["nexthops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nexthops is missing from object`)

		return NewNexthopGroupValueUnknown(), diags
	}

	nexthopsVal, ok := nexthopsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nexthops expected to be basetypes.ListValue, was: %T`, nexthopsAttribute))
	}

	resolveAttribute, ok := attributes["resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resolve is missing from object`)

		return NewNexthopGroupValueUnknown(), diags
	}

	resolveVal, ok := resolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resolve expected to be basetypes.BoolValue, was: %T`, resolveAttribute))
	}

	if diags.HasError() {
		return NewNexthopGroupValueUnknown(), diags
	}

	return NexthopGroupValue{
		Bfd:               bfdVal,
		Blackhole:         blackholeVal,
		BlackholeSendIcmp: blackholeSendIcmpVal,
		Nexthops:          nexthopsVal,
		Resolve:           resolveVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNexthopGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NexthopGroupValue {
	object, diags := NewNexthopGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNexthopGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NexthopGroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNexthopGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNexthopGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNexthopGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNexthopGroupValueMust(NexthopGroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NexthopGroupType) ValueType(ctx context.Context) attr.Value {
	return NexthopGroupValue{}
}

var _ basetypes.ObjectValuable = NexthopGroupValue{}

type NexthopGroupValue struct {
	Bfd               basetypes.ObjectValue `tfsdk:"bfd"`
	Blackhole         basetypes.BoolValue   `tfsdk:"blackhole"`
	BlackholeSendIcmp basetypes.BoolValue   `tfsdk:"blackhole_send_icmp"`
	Nexthops          basetypes.ListValue   `tfsdk:"nexthops"`
	Resolve           basetypes.BoolValue   `tfsdk:"resolve"`
	state             attr.ValueState
}

func (v NexthopGroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bfd"] = basetypes.ObjectType{
		AttrTypes: BfdValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["blackhole"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["blackhole_send_icmp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nexthops"] = basetypes.ListType{
		ElemType: NexthopsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["resolve"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Bfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.Blackhole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blackhole"] = val

		val, err = v.BlackholeSendIcmp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blackhole_send_icmp"] = val

		val, err = v.Nexthops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nexthops"] = val

		val, err = v.Resolve.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resolve"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NexthopGroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NexthopGroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NexthopGroupValue) String() string {
	return "NexthopGroupValue"
}

func (v NexthopGroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd basetypes.ObjectValue

	if v.Bfd.IsNull() {
		bfd = types.ObjectNull(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd.IsUnknown() {
		bfd = types.ObjectUnknown(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd.IsNull() && !v.Bfd.IsUnknown() {
		bfd = types.ObjectValueMust(
			BfdValue{}.AttributeTypes(ctx),
			v.Bfd.Attributes(),
		)
	}

	nexthops := types.ListValueMust(
		NexthopsType{
			basetypes.ObjectType{
				AttrTypes: NexthopsValue{}.AttributeTypes(ctx),
			},
		},
		v.Nexthops.Elements(),
	)

	if v.Nexthops.IsNull() {
		nexthops = types.ListNull(
			NexthopsType{
				basetypes.ObjectType{
					AttrTypes: NexthopsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Nexthops.IsUnknown() {
		nexthops = types.ListUnknown(
			NexthopsType{
				basetypes.ObjectType{
					AttrTypes: NexthopsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"blackhole":           basetypes.BoolType{},
		"blackhole_send_icmp": basetypes.BoolType{},
		"nexthops": basetypes.ListType{
			ElemType: NexthopsValue{}.Type(ctx),
		},
		"resolve": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bfd":                 bfd,
			"blackhole":           v.Blackhole,
			"blackhole_send_icmp": v.BlackholeSendIcmp,
			"nexthops":            nexthops,
			"resolve":             v.Resolve,
		})

	return objVal, diags
}

func (v NexthopGroupValue) Equal(o attr.Value) bool {
	other, ok := o.(NexthopGroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bfd.Equal(other.Bfd) {
		return false
	}

	if !v.Blackhole.Equal(other.Blackhole) {
		return false
	}

	if !v.BlackholeSendIcmp.Equal(other.BlackholeSendIcmp) {
		return false
	}

	if !v.Nexthops.Equal(other.Nexthops) {
		return false
	}

	if !v.Resolve.Equal(other.Resolve) {
		return false
	}

	return true
}

func (v NexthopGroupValue) Type(ctx context.Context) attr.Type {
	return NexthopGroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NexthopGroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"blackhole":           basetypes.BoolType{},
		"blackhole_send_icmp": basetypes.BoolType{},
		"nexthops": basetypes.ListType{
			ElemType: NexthopsValue{}.Type(ctx),
		},
		"resolve": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = BfdType{}

type BfdType struct {
	basetypes.ObjectType
}

func (t BfdType) Equal(o attr.Type) bool {
	other, ok := o.(BfdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BfdType) String() string {
	return "BfdType"
}

func (t BfdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localAddressAttribute, ok := attributes["local_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_address is missing from object`)

		return nil, diags
	}

	localAddressVal, ok := localAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_address expected to be basetypes.StringValue, was: %T`, localAddressAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BfdValue{
		Enabled:      enabledVal,
		LocalAddress: localAddressVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewBfdValueNull() BfdValue {
	return BfdValue{
		state: attr.ValueStateNull,
	}
}

func NewBfdValueUnknown() BfdValue {
	return BfdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBfdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BfdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BfdValue Attribute Value",
				"While creating a BfdValue value, a missing attribute value was detected. "+
					"A BfdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BfdValue Attribute Type",
				"While creating a BfdValue value, an invalid attribute value was detected. "+
					"A BfdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BfdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BfdValue Attribute Value",
				"While creating a BfdValue value, an extra attribute value was detected. "+
					"A BfdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BfdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localAddressAttribute, ok := attributes["local_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_address is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	localAddressVal, ok := localAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_address expected to be basetypes.StringValue, was: %T`, localAddressAttribute))
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	return BfdValue{
		Enabled:      enabledVal,
		LocalAddress: localAddressVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewBfdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BfdValue {
	object, diags := NewBfdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BfdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfdValueMust(BfdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BfdType) ValueType(ctx context.Context) attr.Value {
	return BfdValue{}
}

var _ basetypes.ObjectValuable = BfdValue{}

type BfdValue struct {
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	LocalAddress basetypes.StringValue `tfsdk:"local_address"`
	state        attr.ValueState
}

func (v BfdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["local_address"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.LocalAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_address"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BfdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BfdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BfdValue) String() string {
	return "BfdValue"
}

func (v BfdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":       basetypes.BoolType{},
		"local_address": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":       v.Enabled,
			"local_address": v.LocalAddress,
		})

	return objVal, diags
}

func (v BfdValue) Equal(o attr.Value) bool {
	other, ok := o.(BfdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.LocalAddress.Equal(other.LocalAddress) {
		return false
	}

	return true
}

func (v BfdValue) Type(ctx context.Context) attr.Type {
	return BfdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BfdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":       basetypes.BoolType{},
		"local_address": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NexthopsType{}

type NexthopsType struct {
	basetypes.ObjectType
}

func (t NexthopsType) Equal(o attr.Type) bool {
	other, ok := o.(NexthopsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NexthopsType) String() string {
	return "NexthopsType"
}

func (t NexthopsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bfd1Attribute, ok := attributes["bfd_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_1 is missing from object`)

		return nil, diags
	}

	bfd1Val, ok := bfd1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_1 expected to be basetypes.ObjectValue, was: %T`, bfd1Attribute))
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	resolveAttribute, ok := attributes["resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resolve is missing from object`)

		return nil, diags
	}

	resolveVal, ok := resolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resolve expected to be basetypes.BoolValue, was: %T`, resolveAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NexthopsValue{
		Bfd1:     bfd1Val,
		IpPrefix: ipPrefixVal,
		Resolve:  resolveVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewNexthopsValueNull() NexthopsValue {
	return NexthopsValue{
		state: attr.ValueStateNull,
	}
}

func NewNexthopsValueUnknown() NexthopsValue {
	return NexthopsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNexthopsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NexthopsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NexthopsValue Attribute Value",
				"While creating a NexthopsValue value, a missing attribute value was detected. "+
					"A NexthopsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NexthopsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NexthopsValue Attribute Type",
				"While creating a NexthopsValue value, an invalid attribute value was detected. "+
					"A NexthopsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NexthopsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NexthopsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NexthopsValue Attribute Value",
				"While creating a NexthopsValue value, an extra attribute value was detected. "+
					"A NexthopsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NexthopsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNexthopsValueUnknown(), diags
	}

	bfd1Attribute, ok := attributes["bfd_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_1 is missing from object`)

		return NewNexthopsValueUnknown(), diags
	}

	bfd1Val, ok := bfd1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_1 expected to be basetypes.ObjectValue, was: %T`, bfd1Attribute))
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewNexthopsValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	resolveAttribute, ok := attributes["resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resolve is missing from object`)

		return NewNexthopsValueUnknown(), diags
	}

	resolveVal, ok := resolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resolve expected to be basetypes.BoolValue, was: %T`, resolveAttribute))
	}

	if diags.HasError() {
		return NewNexthopsValueUnknown(), diags
	}

	return NexthopsValue{
		Bfd1:     bfd1Val,
		IpPrefix: ipPrefixVal,
		Resolve:  resolveVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewNexthopsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NexthopsValue {
	object, diags := NewNexthopsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNexthopsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NexthopsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNexthopsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNexthopsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNexthopsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNexthopsValueMust(NexthopsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NexthopsType) ValueType(ctx context.Context) attr.Value {
	return NexthopsValue{}
}

var _ basetypes.ObjectValuable = NexthopsValue{}

type NexthopsValue struct {
	Bfd1     basetypes.ObjectValue `tfsdk:"bfd_1"`
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Resolve  basetypes.BoolValue   `tfsdk:"resolve"`
	state    attr.ValueState
}

func (v NexthopsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["bfd_1"] = basetypes.ObjectType{
		AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resolve"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Bfd1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_1"] = val

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Resolve.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resolve"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NexthopsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NexthopsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NexthopsValue) String() string {
	return "NexthopsValue"
}

func (v NexthopsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd1 basetypes.ObjectValue

	if v.Bfd1.IsNull() {
		bfd1 = types.ObjectNull(
			Bfd1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd1.IsUnknown() {
		bfd1 = types.ObjectUnknown(
			Bfd1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd1.IsNull() && !v.Bfd1.IsUnknown() {
		bfd1 = types.ObjectValueMust(
			Bfd1Value{}.AttributeTypes(ctx),
			v.Bfd1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bfd_1": basetypes.ObjectType{
			AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
		},
		"ip_prefix": basetypes.StringType{},
		"resolve":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bfd_1":     bfd1,
			"ip_prefix": v.IpPrefix,
			"resolve":   v.Resolve,
		})

	return objVal, diags
}

func (v NexthopsValue) Equal(o attr.Value) bool {
	other, ok := o.(NexthopsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bfd1.Equal(other.Bfd1) {
		return false
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Resolve.Equal(other.Resolve) {
		return false
	}

	return true
}

func (v NexthopsValue) Type(ctx context.Context) attr.Type {
	return NexthopsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NexthopsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bfd_1": basetypes.ObjectType{
			AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
		},
		"ip_prefix": basetypes.StringType{},
		"resolve":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Bfd1Type{}

type Bfd1Type struct {
	basetypes.ObjectType
}

func (t Bfd1Type) Equal(o attr.Type) bool {
	other, ok := o.(Bfd1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bfd1Type) String() string {
	return "Bfd1Type"
}

func (t Bfd1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localAddressAttribute, ok := attributes["local_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_address is missing from object`)

		return nil, diags
	}

	localAddressVal, ok := localAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_address expected to be basetypes.StringValue, was: %T`, localAddressAttribute))
	}

	localDiscriminatorAttribute, ok := attributes["local_discriminator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_discriminator is missing from object`)

		return nil, diags
	}

	localDiscriminatorVal, ok := localDiscriminatorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_discriminator expected to be basetypes.Int64Value, was: %T`, localDiscriminatorAttribute))
	}

	remoteDiscriminatorAttribute, ok := attributes["remote_discriminator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_discriminator is missing from object`)

		return nil, diags
	}

	remoteDiscriminatorVal, ok := remoteDiscriminatorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_discriminator expected to be basetypes.Int64Value, was: %T`, remoteDiscriminatorAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bfd1Value{
		Enabled:             enabledVal,
		LocalAddress:        localAddressVal,
		LocalDiscriminator:  localDiscriminatorVal,
		RemoteDiscriminator: remoteDiscriminatorVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewBfd1ValueNull() Bfd1Value {
	return Bfd1Value{
		state: attr.ValueStateNull,
	}
}

func NewBfd1ValueUnknown() Bfd1Value {
	return Bfd1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBfd1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bfd1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bfd1Value Attribute Value",
				"While creating a Bfd1Value value, a missing attribute value was detected. "+
					"A Bfd1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bfd1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bfd1Value Attribute Type",
				"While creating a Bfd1Value value, an invalid attribute value was detected. "+
					"A Bfd1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bfd1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bfd1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bfd1Value Attribute Value",
				"While creating a Bfd1Value value, an extra attribute value was detected. "+
					"A Bfd1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bfd1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfd1ValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localAddressAttribute, ok := attributes["local_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_address is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	localAddressVal, ok := localAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_address expected to be basetypes.StringValue, was: %T`, localAddressAttribute))
	}

	localDiscriminatorAttribute, ok := attributes["local_discriminator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_discriminator is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	localDiscriminatorVal, ok := localDiscriminatorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_discriminator expected to be basetypes.Int64Value, was: %T`, localDiscriminatorAttribute))
	}

	remoteDiscriminatorAttribute, ok := attributes["remote_discriminator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_discriminator is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	remoteDiscriminatorVal, ok := remoteDiscriminatorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_discriminator expected to be basetypes.Int64Value, was: %T`, remoteDiscriminatorAttribute))
	}

	if diags.HasError() {
		return NewBfd1ValueUnknown(), diags
	}

	return Bfd1Value{
		Enabled:             enabledVal,
		LocalAddress:        localAddressVal,
		LocalDiscriminator:  localDiscriminatorVal,
		RemoteDiscriminator: remoteDiscriminatorVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewBfd1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bfd1Value {
	object, diags := NewBfd1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfd1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bfd1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfd1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfd1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfd1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfd1ValueMust(Bfd1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bfd1Type) ValueType(ctx context.Context) attr.Value {
	return Bfd1Value{}
}

var _ basetypes.ObjectValuable = Bfd1Value{}

type Bfd1Value struct {
	Enabled             basetypes.BoolValue   `tfsdk:"enabled"`
	LocalAddress        basetypes.StringValue `tfsdk:"local_address"`
	LocalDiscriminator  basetypes.Int64Value  `tfsdk:"local_discriminator"`
	RemoteDiscriminator basetypes.Int64Value  `tfsdk:"remote_discriminator"`
	state               attr.ValueState
}

func (v Bfd1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["local_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_discriminator"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remote_discriminator"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.LocalAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_address"] = val

		val, err = v.LocalDiscriminator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_discriminator"] = val

		val, err = v.RemoteDiscriminator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_discriminator"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bfd1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bfd1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bfd1Value) String() string {
	return "Bfd1Value"
}

func (v Bfd1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":              basetypes.BoolType{},
		"local_address":        basetypes.StringType{},
		"local_discriminator":  basetypes.Int64Type{},
		"remote_discriminator": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":              v.Enabled,
			"local_address":        v.LocalAddress,
			"local_discriminator":  v.LocalDiscriminator,
			"remote_discriminator": v.RemoteDiscriminator,
		})

	return objVal, diags
}

func (v Bfd1Value) Equal(o attr.Value) bool {
	other, ok := o.(Bfd1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.LocalAddress.Equal(other.LocalAddress) {
		return false
	}

	if !v.LocalDiscriminator.Equal(other.LocalDiscriminator) {
		return false
	}

	if !v.RemoteDiscriminator.Equal(other.RemoteDiscriminator) {
		return false
	}

	return true
}

func (v Bfd1Value) Type(ctx context.Context) attr.Type {
	return Bfd1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bfd1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":              basetypes.BoolType{},
		"local_address":        basetypes.StringType{},
		"local_discriminator":  basetypes.Int64Type{},
		"remote_discriminator": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		Nodes:             nodesVal,
		OperationalState:  operationalStateVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		Nodes:             nodesVal,
		OperationalState:  operationalStateVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Health            basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason basetypes.StringValue `tfsdk:"health_score_reason"`
	LastChange        basetypes.StringValue `tfsdk:"last_change"`
	Nodes             basetypes.ListValue   `tfsdk:"nodes"`
	OperationalState  basetypes.StringValue `tfsdk:"operational_state"`
	state             attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var nodesVal basetypes.ListValue
	switch {
	case v.Nodes.IsUnknown():
		nodesVal = types.ListUnknown(types.StringType)
	case v.Nodes.IsNull():
		nodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodesVal, d = types.ListValue(types.StringType, v.Nodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"health":              basetypes.Int64Type{},
			"health_score_reason": basetypes.StringType{},
			"last_change":         basetypes.StringType{},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"operational_state": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"operational_state": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"health":              v.Health,
			"health_score_reason": v.HealthScoreReason,
			"last_change":         v.LastChange,
			"nodes":               nodesVal,
			"operational_state":   v.OperationalState,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"operational_state": basetypes.StringType{},
	}
}
